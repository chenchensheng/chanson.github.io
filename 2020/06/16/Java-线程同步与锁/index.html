<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java 线程同步与锁锁的相关概念按照其性质分类公平锁, 非公平锁公平锁 多个线程按照申请锁的顺序来获取锁 优点: 等待锁的线程不会长时间获取不到锁 缺点: 吞吐效率不高, 因为还要对顺序进行判断  非公平锁 多个线程随机获取锁 优点: 吞吐效率高 缺点: 等待锁的线程可能长时间获取不到锁  悲观锁, 乐观锁悲观锁 认为在使用数据的时候一定有别的线程来修改数据, 因此在获取数据的时候会先加锁, 确">
<meta name="keywords" content="java,multithread,concurrency">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程同步与锁">
<meta property="og:url" content="https://chansonchan.cn/2020/06/16/Java-线程同步与锁/index.html">
<meta property="og:site_name" content="Chanson&#39;s blog">
<meta property="og:description" content="Java 线程同步与锁锁的相关概念按照其性质分类公平锁, 非公平锁公平锁 多个线程按照申请锁的顺序来获取锁 优点: 等待锁的线程不会长时间获取不到锁 缺点: 吞吐效率不高, 因为还要对顺序进行判断  非公平锁 多个线程随机获取锁 优点: 吞吐效率高 缺点: 等待锁的线程可能长时间获取不到锁  悲观锁, 乐观锁悲观锁 认为在使用数据的时候一定有别的线程来修改数据, 因此在获取数据的时候会先加锁, 确">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162306239363236383f773d37323026683d32353026663d6a70656726733d3337323831.jpeg">
<meta property="og:image" content="https://camo.githubusercontent.com/3579362e569b9ea6046cf34702dba32eceb212bb/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162323461633733643f773d38363926683d33353126663d706e6726733d3331313531">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/image-20200718211006217.png">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/7132e4cef44c26f62835b197b239147b18062.png">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/82077ccf14127a87b77cefd1ccf562d3253591.png">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/27605d483e8935da683a93be015713f331378.png">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/3f1e1a44f5b7d77000ba4f9476189b2e32806.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/Ciqah157DAiAK_DJAAC0JawhGp4730.png">
<meta property="og:updated_time" content="2020-08-23T05:59:10.272Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 线程同步与锁">
<meta name="twitter:description" content="Java 线程同步与锁锁的相关概念按照其性质分类公平锁, 非公平锁公平锁 多个线程按照申请锁的顺序来获取锁 优点: 等待锁的线程不会长时间获取不到锁 缺点: 吞吐效率不高, 因为还要对顺序进行判断  非公平锁 多个线程随机获取锁 优点: 吞吐效率高 缺点: 等待锁的线程可能长时间获取不到锁  悲观锁, 乐观锁悲观锁 认为在使用数据的时候一定有别的线程来修改数据, 因此在获取数据的时候会先加锁, 确">
<meta name="twitter:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162306239363236383f773d37323026683d32353026663d6a70656726733d3337323831.jpeg">





  
  
  <link rel="canonical" href="https://chansonchan.cn/2020/06/16/Java-线程同步与锁/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java 线程同步与锁 | Chanson's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chanson's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chansonchan.cn/2020/06/16/Java-线程同步与锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chaosn Chan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chanson's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 线程同步与锁

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-06-16 22:42:26" itemprop="dateCreated datePublished" datetime="2020-06-16T22:42:26+08:00">2020-06-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-08-23 13:59:10" itemprop="dateModified" datetime="2020-08-23T13:59:10+08:00">2020-08-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2020/06/16/Java-线程同步与锁/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2020/06/16/Java-线程同步与锁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java-线程同步与锁"><a href="#Java-线程同步与锁" class="headerlink" title="Java 线程同步与锁"></a>Java 线程同步与锁</h1><h2 id="锁的相关概念"><a href="#锁的相关概念" class="headerlink" title="锁的相关概念"></a>锁的相关概念</h2><h3 id="按照其性质分类"><a href="#按照其性质分类" class="headerlink" title="按照其性质分类"></a>按照其性质分类</h3><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁, 非公平锁"></a>公平锁, 非公平锁</h4><h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><ul>
<li>多个线程按照申请锁的顺序来获取锁</li>
<li>优点: 等待锁的线程不会长时间获取不到锁</li>
<li>缺点: 吞吐效率不高, 因为还要对顺序进行判断</li>
</ul>
<h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><ul>
<li>多个线程随机获取锁</li>
<li>优点: 吞吐效率高</li>
<li>缺点: 等待锁的线程可能长时间获取不到锁</li>
</ul>
<h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁, 乐观锁"></a>悲观锁, 乐观锁</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul>
<li>认为在使用数据的时候一定有别的线程来修改数据, 因此在获取数据的时候会先加锁, 确保数据不会被别的线程修改</li>
<li>适合写操作多的场景, 先加锁可以保证写操作时数据正确</li>
<li><code>synchronized</code> 关键字和 <code>Lock</code> 的实现类都是悲观锁</li>
</ul>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul>
<li>认为在使用数据时不会有别的线程修改数据, 所以不会添加锁, 只在更新数据的时候去判断之前有没有别的线程更新了这个数据<ul>
<li>如果数据已经被其他线程更新, 则根据不同的实现方式执行不同的操作（例如报错或者自动重试）</li>
</ul>
</li>
<li>适合读操作多的场景, 避免读的时候被阻塞</li>
<li>在 Java 中是通过使用无锁编程来实现, 最常采用的是 CAS 算法, Java 原子类中的递增操作就通过 CAS 自旋实现的</li>
</ul>
<h6 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h6><ul>
<li>全称 Compare And Swap (比较与交换)</li>
<li>CAS 涉及到三个操作数<ol>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>要写入的新值 B</li>
</ol>
</li>
<li>当且仅当 V 的值等于 A 时, CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作）</li>
<li>存在的问题<ul>
<li><strong>ABA 问题</strong><ul>
<li>在 CAS 操作时, 其他线程将变量值 A 改为了 B, 但是又被改回了 A, 等到本线程使用期望值 A 与当前变量进行比较时, 发现变量 A 没有变, 于是 CAS 就将 A 值进行了交换操作, 但是实际上该值已经被其他线程改变过</li>
<li>解决思路是在变量前面添加版本号, 每次变量更新的时候都把版本号加一, 这样变化过程就从 “A－B－A” 变成了 “1A－2B－3A”</li>
<li>JDK 从 1.5 开始提供了 <code>AtomicStampedReference</code> 类来解决 ABA 问题, 具体操作封装在 <code>compareAndSet()</code> 中<ul>
<li><code>compareAndSet()</code> 首先检查当前引用和当前标志与预期引用和预期标志是否相等, 如果都相等, 则进行 CAS</li>
</ul>
</li>
</ul>
</li>
<li><strong>循环时间长开销大</strong><ul>
<li>CAS 操作如果长时间不成功, 会导致其一直自旋, 给 CPU 带来非常大的开销</li>
</ul>
</li>
<li><strong>只能保证一个共享变量的原子操作</strong><ul>
<li>JDK 从 1.5 开始提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性, 可以把多个变量放在一个对象里来进行 CAS 操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul>
<li>在同一个线程在获取锁之后, 再次获取相同的锁时, 不会因为之前已经获取过还没释放而阻塞</li>
<li>Java 中 <code>ReentrantLock</code> 和 <code>synchronized</code> 都是可重入锁</li>
<li>优点: 可一定程度避免死锁</li>
</ul>
<h4 id="独享锁-排他锁-共享锁-互斥锁-读写锁"><a href="#独享锁-排他锁-共享锁-互斥锁-读写锁" class="headerlink" title="独享锁 (排他锁), 共享锁, 互斥锁, 读写锁"></a>独享锁 (排他锁), 共享锁, 互斥锁, 读写锁</h4><ul>
<li>独享锁 (排他锁), 共享锁是一种广义的说法, 互斥锁, 读写锁是具体的实现</li>
</ul>
<h5 id="独享锁"><a href="#独享锁" class="headerlink" title="独享锁"></a>独享锁</h5><ul>
<li>该锁一次只能被一个线程所持有</li>
<li>获得独享锁的线程即能读数据又能修改数据</li>
<li>JDK 中的 <code>synchronized</code> 和 JUC 中 <code>Lock</code> 的实现类就是互斥锁</li>
</ul>
<h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><ul>
<li>该锁可被多个线程所持有</li>
<li>获得共享锁的线程只能读数据, 不能修改数据</li>
<li>JUC 中 <code>ReadWriteLock</code> 的实现类其读锁是共享锁, 其写锁是独享锁</li>
<li>优点: 可保证并发读, 提高读的效率</li>
</ul>
<h3 id="按照设计方案来分类"><a href="#按照设计方案来分类" class="headerlink" title="按照设计方案来分类"></a>按照设计方案来分类</h3><h4 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁, 适应性自旋锁"></a>自旋锁, 适应性自旋锁</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><ul>
<li>指尝试获取锁的线程不会立即阻塞, 而是采用循环的方式去尝试获取锁</li>
<li>优点: 减少线程上下文切换的消耗</li>
<li>缺点: 循环会一直占用 CPU</li>
</ul>
<h5 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h5><ul>
<li>自适应意味着自旋的时间（次数）不再固定, 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li>
</ul>
<h4 id="锁粗化-锁消除"><a href="#锁粗化-锁消除" class="headerlink" title="锁粗化, 锁消除"></a>锁粗化, 锁消除</h4><ul>
<li>锁粗化和锁消除是虚拟机即时编译器 (JIT) 对锁的优化</li>
</ul>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><ul>
<li>如果一系列的连续操作都对同一个对象反复加锁和解锁, 甚至加锁操作是出现在循环体中的</li>
<li>即使没有线程竞争, 频繁地进行互斥同步操作也会导致不必要的性能损耗</li>
<li>如果 JIT 探测到有这样的操作, 将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</li>
</ul>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><ul>
<li>JIT 在运行时检测到某些代码上要求同步, 但是不可能存在锁竞争, 会对其进行消除</li>
<li>主要判定依据来源于逃逸分析的数据支持, 如果判断在一段代码中, 堆上的所有数据都不会逃逸出去从而被其他线程访问到, 那就可以把它们当做栈上数据对待, 认为它们是线程私有的, 同步加锁自然就无须进行</li>
</ul>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><ul>
<li>分段锁是一种锁的设计, 并不是具体的一种锁</li>
<li><code>ConcurrentHashMap</code> 就是用分段锁实现的<ul>
<li>内部持有一个 Entry 数组, 数组中的每个元素又是一个链表, 同时又是一个锁 (<code>ReentrantLock</code>)</li>
<li>当需要 put 元素的时候, 并不是对整个 hashmap 进行加锁, 而是先通过 hashcode 来知道他要放在那一个分段中, 然后对这个分段进行加锁, 所以当多线程 put 的时候, 只要不是放在一个分段中, 可以并行插入</li>
<li>在统计 size 的时候, 因为是获取全局信息, 所以需要获取所有的分段锁才能统计</li>
</ul>
</li>
</ul>
<h4 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁, 偏向锁, 轻量级锁, 重量级锁"></a>无锁, 偏向锁, 轻量级锁, 重量级锁</h4><ul>
<li>这四种锁是指锁的状态, 在 JDK 1.6 中引入针对 <code>synchronized</code> 的锁优化</li>
<li>级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁</li>
<li>锁状态只能升级不能降级 ( JVM中的锁也是能降级的, 不过条件很苛刻 )</li>
</ul>
<h5 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h5><ul>
<li>无锁没有对资源进行锁定, 所有的线程都能访问并修改同一个资源, 但同时只有一个线程能修改成功</li>
<li>CAS 原理及应用即是无锁的实现</li>
</ul>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><ul>
<li>偏向锁是指一段同步代码一直被一个线程所访问, 那么该线程会自动获取锁, 降低获取锁的代价</li>
<li>直到另一个线程尝试获取此锁的时候, 偏向锁模式才会结束</li>
<li>偏向锁可以提高带有同步但无竞争的程序性能, 但如果在多数锁总会被不同的线程访问时, 偏向锁模式就比较多余</li>
<li>偏向锁在 JDK 1.6 以上默认开启<ul>
<li>可以通过 JVM 参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>, 关闭之后程序默认会进入轻量级锁状态</li>
</ul>
</li>
<li>当 JVM 认为存在多线程竞争时, 会将偏向锁升级为轻量级锁</li>
</ul>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><ul>
<li><p>轻量级锁作用于不同的线程交替的执行同步块中的代码, 不存在锁竞争的情况</p>
</li>
<li><p>只要存在锁竞争, 轻量级锁就会升级为重量级锁</p>
</li>
</ul>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><ul>
<li>重量级锁会让其他申请的线程进入阻塞, 性能降低</li>
</ul>
<h2 id="思考-如何实现锁"><a href="#思考-如何实现锁" class="headerlink" title="思考: 如何实现锁"></a>思考: 如何实现锁</h2><ul>
<li>如果要实现操作系统的锁, 该如何实现？先暂时不考虑性能、可用性等问题, 从最简单粗暴的方式开始思考, 以下都为伪代码</li>
</ul>
<h3 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> except, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS 操作, 修改 status 成功则返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码通过自旋和 CAS 来实现一个最简单的锁</li>
<li>这样实现的锁显然有个致命的缺点：耗费 CPU 资源, 没有竞争到锁的线程会一直占用 CPU 资源进行 CAS 操作</li>
</ul>
<h3 id="yield-自旋"><a href="#yield-自旋" class="headerlink" title="yield + 自旋"></a>yield + 自旋</h3><ul>
<li>要解决自旋锁的性能问题必须让竞争锁失败的线程不<strong>忙等</strong>, 而是在获取不到锁的时候能把 CPU 资源给让出来, 说到让 CPU 资源, 可能想到了 <code>yield()</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>yield()</code> 方法并没有完全解决问题<ul>
<li><code>yield()</code> 不一定能成功让出 CPU, 还跟线程的优先级有关</li>
<li>如果有 100 个线程竞争锁, 当线程 1 获得锁后, 还有 99 个线程在反复的自旋 + yield, 假如运行在单核 CPU 下, 在竞争锁时最差只有 1% 的 CPU 利用率, 导致获得锁的线程 1 一直被中断, 执行实际业务代码时间变得更长, 从而导致锁释放的时间变的更长</li>
</ul>
</li>
</ul>
<h3 id="sleep-自旋"><a href="#sleep-自旋" class="headerlink" title="sleep + 自旋"></a>sleep + 自旋</h3><ul>
<li>当竞争锁失败后, 可以将用 <code>Thread.sleep</code> 将线程休眠, 从而不占用 CPU 资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通常用于实现上层锁, 不适合用于操作系统级别的锁, 因为作为一个底层锁, 其 sleep 时间很难设置<ul>
<li>sleep 的时间取决于同步代码块的执行时间</li>
<li>sleep 时间如果太短了, 会导致线程切换频繁 (极端情况和 yield 方式一样)</li>
<li>sleep 时间如果设置的过长, 会导致线程不能及时获得锁</li>
</ul>
</li>
</ul>
<h3 id="park-自旋"><a href="#park-自旋" class="headerlink" title="park + 自旋"></a>park + 自旋</h3><ul>
<li>那可不可以在获取不到锁的时候让线程释放 CPU 资源进行等待, 当持有锁的线程释放锁的时候将等待的线程唤起呢？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Queue parkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        lock_wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock_notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当期线程加入到等待队列</span></span><br><span class="line">    parkQueue.add(nowThread);</span><br><span class="line">    <span class="comment">// 将当期线程释放CPU</span></span><br><span class="line">    releaseCPU();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到要唤醒的线程</span></span><br><span class="line">    Thread t = parkQueue.poll();</span><br><span class="line">    <span class="comment">// 唤醒等待线程</span></span><br><span class="line">    wakeAThread(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方案相比于 sleep 而言, 只有在锁被释放的时候, 竞争锁的线程才会被唤醒, 不会存在过早或过晚唤醒的问题</li>
</ul>
<h3 id="对于锁冲突不严重的情况-用自旋锁会更适合"><a href="#对于锁冲突不严重的情况-用自旋锁会更适合" class="headerlink" title="对于锁冲突不严重的情况, 用自旋锁会更适合"></a>对于锁冲突不严重的情况, 用自旋锁会更适合</h3><ul>
<li>试想每个线程获得锁后很短的一段时间内就释放锁, 竞争锁的线程只要经历几次自旋运算后就能获得锁, 那就没必要等待该线程了</li>
<li>因为等待线程意味着需要进入到内核态进行上下文切换, 而上下文切换的成本不低, 如果锁很快就释放了, 那上下文切换的开销将超过自旋</li>
<li>目前操作系统中, 一般是用<strong>自旋+等待</strong>结合的形式实现锁：在进入锁时先自旋一定次数, 如果还没获得锁再进行等待</li>
</ul>
<h2 id="linux-如何实现锁"><a href="#linux-如何实现锁" class="headerlink" title="linux 如何实现锁"></a>linux 如何实现锁</h2><ul>
<li><p>linux 底层用 futex 实现锁</p>
</li>
<li><p>futex 由一个内核层的队列和一个用户空间层的 atomic integer 构成</p>
</li>
<li><p>当获得锁时, 尝试 CAS 更改 integer, 如果 integer 原始值是 0, 则修改成功, 该线程获得锁</p>
</li>
<li><p>否则就将当前线程放入到 wait queue中（即操作系统的等待队列）</p>
</li>
</ul>
<h3 id="futex-诞生之前"><a href="#futex-诞生之前" class="headerlink" title="futex 诞生之前"></a>futex 诞生之前</h3><ul>
<li><p>在 futex 诞生之前, linux 下的同步机制可以归为两类</p>
<ol>
<li>用户态的同步机制<ul>
<li>基本上就是利用原子指令实现的自旋锁 (代码层的 CAS)</li>
<li>关于自旋锁其缺点也说过了, 不适用于大的临界区（即锁占用时间比较长的情况）</li>
</ul>
</li>
<li>内核同步机制<ul>
<li>如 semaphore (信号量) 等, 使用的是上文说的<strong>自旋+等待</strong>的形式</li>
<li>它对于大小临界区和都适用</li>
<li>但是因为它是内核层的 (释放 CPU 资源是内核级调用), 所以每次 lock 与 unlock 都是一次系统调用, 即使没有锁冲突, 也必须要通过系统调用进入内核之后才能识别</li>
</ul>
</li>
</ol>
</li>
<li><p>理想的同步机制应该是没有锁冲突时在用户态利用原子指令就解决问题, 而需要挂起等待时再使用内核提供的系统调用进行睡眠与唤醒。换句话说, 在用户态的自旋失败时, 能不能让进程挂起, 由持有锁的线程释放锁时将其唤醒？</p>
</li>
<li><p>可能会想出以下代码</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">int</span> lockval)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// trylock 是用户级的自旋锁</span></span><br><span class="line">    <span class="keyword">while</span>(!trylock(lockval)) &#123;</span><br><span class="line">        wait(); <span class="comment">// 释放 CPU, 并将当期线程加入等待队列, 是系统调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">trylock</span><span class="params">(<span class="keyword">int</span> lockval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// localval = 1 代表上锁成功</span></span><br><span class="line">    <span class="keyword">while</span>(!compareAndSet(lockval, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(++i &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">int</span> lockval)</span> </span>&#123;</span><br><span class="line">     compareAndSet(lockval, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">     notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述代码的问题是 <code>trylock</code> 和 <code>wait</code> 两个调用之间存在一个窗口, 如果一个线程 <code>trylock</code> 失败后在调用 <code>wait</code> 前, 持有锁的线程释放了锁, 则该线程执行完 <code>wait</code> 后就无人唤醒了</p>
</li>
</ul>
</li>
</ul>
<h3 id="futex-诞生之后"><a href="#futex-诞生之后" class="headerlink" title="futex 诞生之后"></a>futex 诞生之后</h3><ul>
<li><p>我们来看看 futex 的方法定义</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uaddr 指向一个地址, val 代表这个地址期待的值, 当 *uaddr == val 时, 才会进行 wait</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wait</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒 n 个在 uaddr 指向的锁变量上挂起等待的进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wake</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>futex_wait</code> 真正将进程挂起之前会检查 uaddr 指向的地址的值是否等于 val, 如果不相等则会立即返回, 由用户态继续 trylock, 否则将当前线程插入到一个队列中去并挂起</p>
</li>
<li><p><code>futex_wait</code> 检查 uaddr 的值前会获取自旋锁, 将当前线程插入等待队列后释放, 最后再挂起线程, 保证条件与等待之间的原子性</p>
</li>
<li><p>futex 内部维护了一个队列, 在线程挂起前会线程插入到其中, 同时对于队列中的每个节点都有一个标识, 代表该线程关联锁的uaddr。这样当用户态调用 <code>futex_wake</code> 时, 只需要遍历这个等待队列, 把带有相同 <code>uaddr</code> 的节点所对应的进程唤醒就行了</p>
</li>
<li><p>作为优化, futex 维护的其实是个类似 Java 中的 <code>ConcurrentHashMap</code> 的结构, 也就是数组加链表的形式</p>
<ul>
<li>其持有一个总链表, 总链表中每个元素都是一个带有自旋锁的子链表</li>
<li>调用 <code>futex_wait</code> 挂起的进程, 通过其 uaddr hash 放到某一个具体的子链表上去</li>
<li>这样一方面能分散对等待队列的竞争、另一方面减小单个队列的长度, 便于 <code>futex_wake</code> 时的查找</li>
<li>每个链表各自持有一把spinlock, 将 <strong><u>*uaddr 和 val 的比较操作</u></strong> 与 <strong><u>把进程加入队列的操作</u></strong> 保护在一个临界区中</li>
</ul>
</li>
<li><p>futex 是支持多进程的, 当使用 futex 在多进程间进行同步时, 需要考虑同一个物理内存地址在不同进程中的虚拟地址是不同的</p>
</li>
</ul>
</li>
</ul>
<h2 id="Java-如何实现锁"><a href="#Java-如何实现锁" class="headerlink" title="Java 如何实现锁"></a>Java 如何实现锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>在 JDK 1.6 中引入针对 <code>synchronized</code> 进行了锁优化, 分为无锁、偏向锁、轻量级锁和重量级锁四种状态</li>
<li>在前面锁的概念中有介绍各个锁的使用场景</li>
</ul>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul>
<li><p>在 Java 中任意对象都可以用作锁, 因此必定要有一个映射关系, 存储该对象以及其对应的锁信息（比如当前哪个线程持有锁, 哪些线程在等待）</p>
</li>
<li><p>在 JVM 中, 对象在内存中除了本身的数据外还会有个对象头</p>
<ul>
<li>对于普通对象而言, 其对象头中有两类信息：<code>mark word</code> 和类型指针<ul>
<li><code>mark word</code> 用于存储对象的 HashCode、GC分代年龄、锁状态等信息<ul>
<li>在 32 位系统上 <code>mark word</code> 长度为 32bit, 64 位系统上长度为 64bit</li>
<li>为了能在有限的空间里存储下更多的数据, 其存储格式是不固定的, 在 32 位系统上各状态的格式如下：<ul>
<li><img src="https://gitee.com/chansonchan/image/raw/master/uPic/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162306239363236383f773d37323026683d32353026663d6a70656726733d3337323831.jpeg" alt="image"></li>
</ul>
</li>
</ul>
</li>
<li>类型指针是指向该对象所属类对象的指针</li>
</ul>
</li>
<li>对于数组而言还会有一份记录数组长度的数据</li>
</ul>
</li>
</ul>
<h4 id="重量级锁-1"><a href="#重量级锁-1" class="headerlink" title="重量级锁"></a>重量级锁</h4><ul>
<li>重量级锁是我们常说的传统意义上的锁, 其利用操作系统底层的同步机制去实现 Java 中的线程同步</li>
<li>重量级锁的状态下, 对象的 <code>mark word</code> 为指向一个堆中 monitor 对象的指针</li>
<li>关于什么是 monitor, 在 &lt;&lt; Java 线程与线程池&gt;&gt; 中有相关深入分析</li>
<li>当调用一个锁对象的 <code>wait</code> 或 <code>notify</code> 方法时, <strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong></li>
</ul>
<h4 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><ul>
<li>网上很多文章说轻量级锁有自旋, 这在源码中是不存在的, 只有重量级锁获取失败才会自旋</li>
<li>线程在执行同步块之前, JVM 会先在当前的线程的栈帧中创建一个 <code>Lock Record</code>, 其包括一个用于存储对象头中的 <code>mark word</code>（官方称之为 <code>Displaced Mark Word</code>）以及一个指向对象的指针。下图右边的部分就是一个<code>Lock Record</code><ul>
<li><img src="https://camo.githubusercontent.com/3579362e569b9ea6046cf34702dba32eceb212bb/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162323461633733643f773d38363926683d33353126663d706e6726733d3331313531" alt="img"></li>
<li><code>Lock Record</code> 是从高往低创建的</li>
</ul>
</li>
</ul>
<h5 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h5><ol>
<li>在线程栈中创建一个 <code>Lock Record</code>, 将其 <code>obj</code>（即上图的 Object reference）字段指向锁对象</li>
<li>直接通过 CAS 将 <code>Lock Record</code> 的地址存储在对象头的 <code>mark word</code> 中<ul>
<li>如果对象处于无锁状态则修改成功, 代表该线程获得了轻量级锁</li>
<li>如果失败, 需要判断是否为当前线程的锁重入<ul>
<li>是, 则设置 <code>Lock Record</code> 第一部分（<code>Displaced Mark Word</code>）为 null, 起到了一个重入计数器的作用</li>
<li>否, 则说明发生了竞争, 需要膨胀为重量级锁</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h5><ol>
<li><p>从低往高遍历线程栈, 找到所有 <code>obj</code> 字段等于当前锁对象的 <code>Lock Record</code></p>
</li>
<li><p>如果 <code>Lock Record</code> 的 <code>Displaced Mark Word</code> 为 null, 代表是重入的解锁, 将 <code>obj</code> 设置为 null </p>
</li>
<li><p>如果 <code>Lock Record</code> 的 <code>Displaced Mark Word</code> 不为 null, 则利用 CAS 将对象头的 <code>mark word</code> 恢复成为 <code>Displaced Mark Word</code></p>
<ul>
<li>如果失败, 则膨胀为重量级锁</li>
</ul>
</li>
</ol>
<h4 id="偏向锁-1"><a href="#偏向锁-1" class="headerlink" title="偏向锁"></a>偏向锁</h4><ul>
<li><p>在 JDK 1.6 以上默认开启</p>
</li>
<li><p>在程序启动后, 通常有几秒的延迟, 可以通过 <code>-XX:BiasedLockingStartupDelay=0</code> 来关闭延迟</p>
</li>
<li><p>当调用锁对象的 <code>Object#hash</code> 或 <code>System.identityHashCode()</code> 方法会导致该对象的偏向锁升级</p>
<ul>
<li>因为对象的 hashcode 是在调用这两个方法时才生成的<ul>
<li>如果是无锁状态则存放在 <code>mark word</code> 中</li>
<li>如果是重量级锁则存放在对应的 monitor 中</li>
<li>而偏向锁没有地方能存放该信息, 所以必须升级</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h5><ul>
<li>当新创建一个对象的时候, 如果该对象所属的 class 没有关闭偏向锁模式（默认开启）, 那新创建对象的 <code>mark word</code> 将是可偏向状态, 此时 <code>mark word</code> 中的 thread id（参见上文偏向状态下的 <code>mark word</code> 格式）为 0, 表示未偏向任何线程, 也叫做匿名偏向 (anonymously biased)</li>
</ul>
<h5 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h5><ul>
<li><p>当该对象第一次被线程获得锁的时候, 发现是匿名偏向状态, 则会用 CAS 将 <code>mark word</code> 中的 thread id 由 0 改成当前线程 Id</p>
<ul>
<li>如果失败, 说明存在另个线程使用锁, 将偏向锁撤销, 升级为轻量级锁</li>
</ul>
</li>
<li><p>当被偏向的线程再次进入同步块时, 发现锁对象偏向的就是当前线程, 在通过一些额外的检查后, 会往当前线程的栈中添加一条 <code>Displaced Mark Word</code> 为 null 的 <code>Lock Record</code> , 然后继续执行同步块的代码, 因为操纵的是线程私有的栈, 因此不需要用到 CAS 指令</p>
</li>
<li><p>当其他线程进入同步块时, 发现已经有偏向的线程了, 则会进入<strong>撤销偏向锁</strong>的逻辑</p>
<ul>
<li>一般来说, 会在 <code>safepoint</code> 中去查看偏向的线程是否还存活<ul>
<li>如果存活且还在同步块中则将锁升级为轻量级锁, 原偏向的线程继续拥有锁, 当前线程则走入到锁升级的逻辑里</li>
<li>如果偏向的线程已经不存活或者不在同步块中, 则将对象头的 <code>mark word</code> 改为无锁状态（unlocked）, 之后再升级为轻量级锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h5><ul>
<li>当有其他线程尝试获得锁时, 是根据遍历偏向线程的 <code>Lock Record</code> 来确定该线程是否还在执行同步块中的代码。因此将栈中的最近一条 <code>Lock Record</code> 的 <code>obj</code> 字段设置为 null 即可</li>
<li>需要注意的是, 偏向锁的解锁步骤中<strong>并不会修改对象头中的 thread id</strong></li>
</ul>
<h5 id="批量重偏向与撤销"><a href="#批量重偏向与撤销" class="headerlink" title="批量重偏向与撤销"></a>批量重偏向与撤销</h5><ul>
<li><p>重偏向指将已偏向的锁对象头 thread id 指向新的线程 id</p>
</li>
<li><p>撤销偏向指将锁的偏向的状态撤销为无锁状态</p>
</li>
<li><p>从上文提到当有其他线程尝试获得锁时, 需要等到 <code>safepoint</code> 时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁</p>
<ul>
<li><p><code>safe point</code> 在 GC 中经常提到, 其代表了一个状态, 在该状态下所有线程都是暂停的, 详细可以看这篇<a href="https://blog.csdn.net/ITer_ZC/article/details/41892567" target="_blank" rel="noopener">文章</a> </p>
</li>
<li><p>如果运行时存在多线程竞争, 那偏向锁的存在不仅不能提高性能, 而且会导致性能下降</p>
</li>
</ul>
</li>
<li><p>因此 JVM 中增加了一种批量重偏向/撤销的机制, 存在如下两种情况：（见官方<a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf" target="_blank" rel="noopener">论文</a>第4小节）</p>
<ol>
<li><p>一个线程创建了大量对象并执行了初始的同步操作, 之后在另一个线程中将这些对象作为锁进行之后的操作。这种情况下会导致大量的偏向锁撤销操作</p>
</li>
<li><p>存在明显多线程竞争的场景下使用偏向锁是不合适的, 例如生产者/消费者队列</p>
</li>
</ol>
</li>
<li><p><strong>批量重偏向</strong>（bulk rebias）机制是为了解决第一种场景, <strong>批量撤销</strong>（bulk revoke）则是为了解决第二种场景</p>
</li>
<li><p>其做法是：以 class 为单位, 为每个 class 维护一个偏向锁撤销计数器</p>
<ul>
<li>每一次该 class 的对象发生偏向撤销操作时, 该计数器 +1</li>
<li>当计数器达到重偏向阈值（默认20）时, JVM 就认为该 class 的偏向锁有问题, 因此会进行批量重偏向</li>
<li>每个 class 还有一个 <code>epoch</code> 字段, 每个处于偏向锁状态对象的 <code>mark word</code> 中也有该字段</li>
<li>其初始值为创建该对象时 class 中的 <code>epoch</code> 的值<ul>
<li>每次发生批量重偏向时, 就将该值 +1, 同时遍历 JVM 中所有线程的栈, 找到该 class 所有正处于加锁状态的偏向锁, 将其 <code>epoch</code> 字段改为新值</li>
<li>下次获得锁时, 发现当前对象的 <code>epoch</code> 值和 class 的 <code>epoch</code> 不相等, 那就算当前已经偏向了其他线程, 也不会执行撤销操作, 而是直接通过 CAS 操作将其 <code>mark word</code> 的 thread id 改成当前线程 id</li>
</ul>
</li>
<li>当达到重偏向阈值后, 假设该 class 计数器继续增长, 当其达到批量撤销的阈值后（默认40）, JVM就认为该 class 的使用场景存在多线程竞争, 会标记该 class 为不可偏向, 之后对于该 class 的锁, 直接走轻量级锁的逻辑</li>
</ul>
</li>
</ul>
<h4 id="锁状态转换流程"><a href="#锁状态转换流程" class="headerlink" title="锁状态转换流程"></a>锁状态转换流程</h4><p><img src="https://gitee.com/chansonchan/image/raw/master/uPic/image-20200718211006217.png" alt="image-20200718211006217"></p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><ul>
<li><p>AQS 是类 <code>AbstractQueuedSynchronizer</code> 的简称, Java 中的大部分同步类 (Lock、Semaphore、ReentrantLock等) 都是基于 AQS 实现的</p>
</li>
<li><p>AQS 是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架</p>
</li>
<li><p>大致原理如下</p>
<ol>
<li>AQS 维护一个 <code>state</code> 变量和一个双向链表, <code>state</code> 用来表示同步状态, 双向链表存储的是等待锁的线程<ul>
<li><img src="https://gitee.com/chansonchan/image/raw/master/uPic/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></li>
</ul>
</li>
<li>加锁时首先调用 <code>tryAcquire</code> 尝试获得锁, 如果获得锁失败, 则将线程插入到双向链表中, 并调用 <code>LockSupport.park()</code> 方法阻塞当前线程</li>
<li>释放锁时调用 <code>LockSupport.unpark()</code> 唤起链表中的第一个节点的线程, 被唤起的线程会重新走一遍竞争锁的流程</li>
</ol>
</li>
</ul>
<h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://gitee.com/chansonchan/image/raw/master/uPic/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p>
<ul>
<li>上图中有颜色的为方法, 无颜色的为属性</li>
<li>总的来说, AQS 框架共分为五层, 自上而下由浅入深, 从 AQS 对外暴露的 API 到底层基础数据<ul>
<li>当有自定义同步器接入时, 只需重写第一层所需要的部分方法即可, 不需要关注底层具体的实现流程</li>
<li>当自定义同步器进行加锁或者解锁操作时, 先经过第一层的 API 进入 AQS 内部方法, 然后经过第二层进行锁的获取, 接着对于获取锁失败的流程, 进入第三层和第四层的等待队列处理, 而这些处理方式均依赖于第五层的基础数据提供层</li>
</ul>
</li>
</ul>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a><code>Node</code></h4><p><code>Node</code> 是 AQS 双向链表中的节点类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 表示线程以共享的模式等待锁</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">  <span class="comment">// 表示线程正在以独占的方式等待锁</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// waitStatus 的状态, 表示线程获取锁的请求已经取消了</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// waitStatus 的状态, 表示节点的后继节点处于挂起等待 unpark 的状态</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// waitStatus 的状态, 表示节点正在等待 condition signal</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">  <span class="comment">// waitStatus 的状态, 当前线程处在 SHARED 情况下, 该字段才会使用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前节点在队列中的状态, 当一个 Node 被初始化的时候的值为 0</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前驱指针</span></span><br><span class="line">  <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后继指针</span></span><br><span class="line">  <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该节点的线程</span></span><br><span class="line">  <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向下一个处于 CONDITION 状态的节点</span></span><br><span class="line">  Node nextWaiter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该节点是否是共享模式</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回前驱节点, 没有的话抛出异常</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    Node p = prev;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">    <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">    <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0 代表锁未被占用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取 State 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 设置State的值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用 CAS 方式更新 State</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这几个方法都是 <code>final</code> 修饰的, 说明子类中无法重写它们</li>
<li>我们可以通过修改 <code>state</code> 字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）<ul>
<li>独占锁通过 <code>state</code> 变量的 0 和 1 两个状态来控制是否有线程占有锁</li>
<li>共享锁通过 <code>state</code> 变量 0 或者非 0 来控制多个线程访问</li>
<li><img src="https://gitee.com/chansonchan/image/raw/master/uPic/27605d483e8935da683a93be015713f331378.png" alt="img"></li>
<li><img src="https://gitee.com/chansonchan/image/raw/master/uPic/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="在-JUC-中的应用"><a href="#在-JUC-中的应用" class="headerlink" title="在 JUC 中的应用"></a>在 JUC 中的应用</h4><table>
<thead>
<tr>
<th align="left">同步工具</th>
<th align="left">同步工具与 AQS 的关联</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ReentrantLock</td>
<td align="left">使用 AQS 保存锁重复持有的次数。当一个线程获取锁时, ReentrantLock 记录当前获得锁的线程标识, 用于检测是否重复获取, 以及错误线程试图解锁操作时异常情况的处理</td>
</tr>
<tr>
<td align="left">Semaphore</td>
<td align="left">使用 AQS 同步状态来保存信号量的当前计数。tryRelease 会增加计数, acquireShared 会减少计数</td>
</tr>
<tr>
<td align="left">CountDownLatch</td>
<td align="left">使用 AQS 同步状态来表示计数。计数为 0 时, 所有的 Acquire 操作（CountDownLatch 的 await 方法）才可以通过</td>
</tr>
<tr>
<td align="left">ReentrantReadWriteLock</td>
<td align="left">使用 AQS 同步状态中的 16 位保存写锁持有的次数, 剩下的 16 位用于保存读锁的持有次数</td>
</tr>
<tr>
<td align="left">ThreadPoolExecutor</td>
<td align="left">Worker 利用 AQS 同步状态实现对独占线程变量的设置（tryAcquire 和 tryRelease）</td>
</tr>
</tbody></table>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><ul>
<li>AQS 中线程的阻塞和唤醒是通过 <code>LockSupport</code> 来实现的</li>
</ul>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li><p><code>UNSAFE</code>: 用于操作内存和一些底层的指令</p>
</li>
<li><p><code>parkBlockerOffset</code>: 记录 <code>parkBlocker</code> 在内存中的偏移量</p>
<ul>
<li><p>在 <code>Thread</code> 中有如下变量</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The argument supplied to the current call to </span></span><br><span class="line"><span class="comment"> * Java.util.concurrent.locks.LockSupport.park. </span></span><br><span class="line"><span class="comment"> * Set by (private) Java.util.concurrent.locks.LockSupport.setBlocker </span></span><br><span class="line"><span class="comment"> * Accessed using Java.util.concurrent.locks.LockSupport.getBlocker </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">volatile</span> Object parkBlocker;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>这个对象是用来记录线程被阻塞时被谁阻塞的, 用于线程监控和分析工具来定位原因</p>
</li>
<li><p>可以通过 <code>LockSupport</code> 的 <code>getBlocker</code> 获取到阻塞的对象</p>
</li>
<li><p>在  <code>LockSupport</code>  初始化的静态代码块中</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">    parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">      (tk.getDeclaredField(<span class="string">"parkBlocker"</span>));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先是通过反射机制获取 <code>Thread</code> 的 <code>parkBlocker</code> 字段对象</li>
<li>然后通过 <code>Unsafe</code> 对象的 <code>objectFieldOffset</code> 方法获取到 <code>parkBlocker</code> 在内存里的偏移量</li>
</ol>
</li>
</ul>
</li>
<li><p>为什么要用偏移量来获取对象?</p>
<ul>
<li><code>parkBlocker</code> 是在线程处于阻塞的情况下才会被赋值</li>
<li>如果不通过这种内存的方法, 而是直接调用线程内的方法, 线程是不会回应调用的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="park-方法"><a href="#park-方法" class="headerlink" title="park 方法"></a><code>park</code> 方法</h5><ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>park</code> 方法调用了 native 方法 <code>UNSAFE.park</code></p>
<ul>
<li>第一个参数表明第二个参数是时间间隔还是时间戳</li>
<li>第二个参数代表最长阻塞时间, 为 0 代表不判断超时</li>
</ul>
</li>
<li><p>被 <code>park</code> 的线程有三种情况会被唤醒, 但是无法知道是哪种原因</p>
<ol>
<li>其他线程调用 <code>unpark</code> 唤醒该线程</li>
<li>其他线程调用该线程的中断, 所以唤醒后需要检查中断状态以响应中断</li>
<li>与 <code>Object.wait</code> 一样会有<strong>虚假唤醒</strong>的情况, 需要配合判断条件在循环中调用</li>
</ol>
</li>
</ul>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>, <code>Sync</code> 继承 <code>AQS</code>, 添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的</li>
<li><code>ReentrantLock</code> 默认使用非公平锁</li>
</ul>
<h4 id="加锁过程-2"><a href="#加锁过程-2" class="headerlink" title="加锁过程"></a>加锁过程</h4><h5 id="ReentrantLock-lock-开始加锁操作"><a href="#ReentrantLock-lock-开始加锁操作" class="headerlink" title="ReentrantLock.lock : 开始加锁操作"></a><code>ReentrantLock.lock</code> : 开始加锁操作</h5><ul>
<li><p><code>lock()</code> 内部调用了抽象方法 <code>sync.lock()</code> , 需要通过 <code>Sync</code> 子类实现</p>
<ul>
<li><p><code>FairSync</code> 中的 <code>lock()</code> </p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进行排队</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>NonfairSync</code> 中的 <code>lock()</code> </p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试将 state 值由 0 置换为 1</span></span><br><span class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非公平锁比公平锁多了一行 <code>compareAndSetState</code> 方法, 如果设置成功说明当前没有其他线程持有该锁, 否则需要通过 <code>acquire</code> 方法进入等待队列</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire"></a><code>AQS.acquire</code></h5><ul>
<li><p><code>acquire</code> 方法位于 AQS 类中</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 尝试获取锁</span></span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 获取锁失败, 加入到阻塞队列, 然后不断尝试获取锁</span></span><br><span class="line">    selfInterrupt(); <span class="comment">// 如果等待过程出现中断, 恢复中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="tryAcquire-尝试获取锁并更新-state"><a href="#tryAcquire-尝试获取锁并更新-state" class="headerlink" title="tryAcquire : 尝试获取锁并更新 state"></a><code>tryAcquire</code> : 尝试获取锁并更新 <code>state</code></h6><ul>
<li><p>先调用 <code>tryAcquire</code> 方法尝试获取锁,  其由子类 <code>NonfairSync</code> 和 <code>FairSync</code> 实现</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果锁没被占用</span></span><br><span class="line">        <span class="comment">// 公平锁比非公平锁多了 !hasQueuedPredecessors() 判断</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 查询是否还有等待时间更久的线程</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 尝试获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 获取成功, 标记被该线程抢占</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 如果为重入的情况</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// int 自增溢出为负数的情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// 记录重入次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="addWaiter-获取锁失败后把线程放入等待队列"><a href="#addWaiter-获取锁失败后把线程放入等待队列" class="headerlink" title="addWaiter : 获取锁失败后把线程放入等待队列"></a><code>addWaiter</code> : 获取锁失败后把线程放入等待队列</h6><ul>
<li><p>如果获取锁失败, 调用 <code>addWaiter</code> 方法把线程包装成 <code>Node</code> 对象, 放入到队列尾部, 并返回该节点</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据当前线程和锁模式新建节点</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 如果尾节点不为空</span></span><br><span class="line">    node.prev = pred; <span class="comment">// 新节点的前驱指针指向尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 将新节点设置为尾节点</span></span><br><span class="line">      pred.next = node; <span class="comment">// 旧的尾节点后驱指针指向新的尾节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enq(node); <span class="comment">// 将节点插入队列中, 如果必要的话进行初始化</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果尾节点为空 (说明队列中没有节点 ), 或者 CAS 失败 (说明已经被别的线程修改), 就需要通过 <code>enq</code> 方法插入节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 初始化头节点, 头节点不储存任何信息</span></span><br><span class="line">        tail = head; <span class="comment">// 尾节点也指向头节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png" alt="img"></p>
</li>
<li><p>现在再来回看下公平锁 <code>tryAcquire</code> 中调用的 <code>hasQueuedPredecessors</code> 方法</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">  <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">  <span class="comment">// thread is first in queue.</span></span><br><span class="line">  Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">  Node h = head;</span><br><span class="line">  Node s;</span><br><span class="line">  <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">    ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双向链表中, <code>head</code> 节点为虚节点, 并不存储任何信息, 只是占位, 真正有数据的节点是在第二个节点开始的</p>
</li>
<li><p><code>addWaiter</code> 中节点入队时不是原子操作, 所以会出现短暂的 <code>head != tail</code> 情况, 当 <code>h != t</code> 时</p>
<ul>
<li>如果 <code>(s = h.next) == null</code>, 说明有线程正在初始化队列, 但只是进行到了 <code>tail</code> 指向 <code>head</code>, 没有将 <code>head</code> 指向 <code>tail</code>, 此时队列中有元素, 需要返回 true</li>
<li>如果 <code>(s = h.next) != null</code>, 说明此时队列中至少有一个有效节点, 并且 <code>s.thread == Thread.currentThread()</code>, 则说明等待队列的第一个有效节点中的线程与当前线程相同, 那么当前线程是可以获取资源的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="acquireQueued-队列中的节点不断尝试获取锁"><a href="#acquireQueued-队列中的节点不断尝试获取锁" class="headerlink" title="acquireQueued :  队列中的节点不断尝试获取锁"></a><code>acquireQueued</code> :  队列中的节点不断尝试获取锁</h6><ul>
<li><p>调用 <code>addWaiter</code> 加入到队列后, 再通过 <code>acquireQueued</code> 方法不断去获取锁, 直到获取成功或者不再需要获取（中断）</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 标记是否成功拿到锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 标记线程等待过程中是否中断过</span></span><br><span class="line">    <span class="comment">// 开始自旋, 要么获取锁, 要么中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取前驱节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 前驱节点为头节点时, 说明当前节点在真实数据队列的首部, 有权尝试获取锁</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node); <span class="comment">// 获取成功, 将当前节点设置为 head 节点</span></span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC // 防止前后互相引用无法回收</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当前节点不在队列首部, 或者在队列首部但没有获取到锁 (可能是非公平锁被抢占了)</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 清理和更新前驱节点状态</span></span><br><span class="line">          parkAndCheckInterrupt()) <span class="comment">// 挂起线程</span></span><br><span class="line">        <span class="comment">// 线程若被中断, 返回 true</span></span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      <span class="comment">// 发生异常, 取消获取锁的请求</span></span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  head = node;</span><br><span class="line">  <span class="comment">// 设置该节点不关联任何线程, 也就是虚节点</span></span><br><span class="line">  node.thread = <span class="keyword">null</span>;</span><br><span class="line">  node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">// 前驱节点的状态为 SIGNAL, 说明当前线程可以被挂起（阻塞）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 若前驱节点状态为 CANCELLED, 那就一直往前找正常等待状态的节点, 这个过程也在清理被取消的节点</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 找到之后将当前节点排在它后边</span></span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断到这里 waitStatus 只可能是 0 或者 PROPAGATE </span></span><br><span class="line">    <span class="comment">// 把前驱节点的状态修改为 SIGNAL</span></span><br><span class="line">    <span class="comment">// 然后 acquireQueued 的循环将会再次 tryAcquire</span></span><br><span class="line">    <span class="comment">// 确保 tryAcquire 失败后会进入上面的 ws == Node.SIGNAL 判断挂起线程</span></span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 挂起</span></span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回并重置中断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>cancelAcquire</code> 方法, 会将 <code>Node</code> 的状态标记为 <code>CANCELLED</code></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将无效节点过滤</span></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过前驱节点, 跳过并清理取消状态的节点</span></span><br><span class="line">  Node pred = node.prev;</span><br><span class="line">  <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">  Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把当前节点的状态设置为 CANCELLED</span></span><br><span class="line">  node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前节点是尾节点, 则将刚刚找到的正常节点设置为尾节点</span></span><br><span class="line">  <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    <span class="comment">// 将 tail 的后继节点指向 null</span></span><br><span class="line">    compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点不是尾节点或者是尾节点但 CAS 失败</span></span><br><span class="line">    <span class="keyword">int</span> ws;</span><br><span class="line">    <span class="comment">// 如果当前节点不是 head 的后继节点</span></span><br><span class="line">    <span class="comment">// 1: 判断当前节点前驱节点的状态是否为 SIGNAL</span></span><br><span class="line">    <span class="comment">// 2: 如果不是, 则尝试把前驱节点状态设置为 SINGAL</span></span><br><span class="line">    <span class="comment">// 如果 1 和 2 中有一个为 true, 再判断前驱节点的线程是否不为 null</span></span><br><span class="line">    <span class="comment">// 如果上述条件都满足, 把当前节点的前驱节点的后继指针指向当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">        ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">         (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">        pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Node next = node.next;</span><br><span class="line">      <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        compareAndSetNext(pred, predNext, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前节点是 head 的后继节点或者上述条件不满足, 那就唤醒当前节点的后继节点</span></span><br><span class="line">      unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.next = node; <span class="comment">// help GC</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><ul>
<li><img src="https://gitee.com/chansonchan/image/raw/master/uPic/Ciqah157DAiAK_DJAAC0JawhGp4730.png" alt="img"></li>
</ul>
<h4 id="解锁过程-2"><a href="#解锁过程-2" class="headerlink" title="解锁过程"></a>解锁过程</h4><h5 id="ReentrantLock-unlock-AQS-release-开始解锁操作"><a href="#ReentrantLock-unlock-AQS-release-开始解锁操作" class="headerlink" title="ReentrantLock.unlock, AQS.release : 开始解锁操作"></a><code>ReentrantLock.unlock</code>, <code>AQS.release</code> : 开始解锁操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试释放锁</span></span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 释放成功</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 头结点不为空并且头结点的 waitStatus 不是初始化节点情况, 解除线程挂起状态</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要 <code>h != null &amp;&amp; h.waitStatus != 0</code> 这样判断<ul>
<li>若 <code>h == null</code>, 则头节点还没初始化, 说明第一个节点还没入队</li>
<li>若 <code>h != null &amp;&amp; h.waitStatus == 0</code> 表明还没有进入等待的后继节点, 不需要唤醒</li>
<li>若 <code>h != null &amp;&amp; h.waitStatus &lt; 0</code> 表明后继节点可能被阻塞了, 需要唤醒</li>
<li>不会出现 <code>h != null &amp;&amp; h.waitStatus &gt; 0</code> 的情况, 只有获得了锁的节点才会成为 head</li>
</ul>
</li>
</ul>
<h5 id="Sync-tryRelease-尝试解锁并更新-state"><a href="#Sync-tryRelease-尝试解锁并更新-state" class="headerlink" title="Sync.tryRelease : 尝试解锁并更新 state"></a><code>Sync.tryRelease</code> : 尝试解锁并更新 <code>state</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 减少可重入次数</span></span><br><span class="line">	<span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">	<span class="comment">// 当前线程不是持有锁的线程, 抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 如果持有线程全部释放, 将当前独占锁所有线程设置为 null, 并更新 state</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		free = <span class="keyword">true</span>;</span><br><span class="line">		setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	setState(c);</span><br><span class="line">	<span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AQS-unparkSuccessor-唤醒后继节点"><a href="#AQS-unparkSuccessor-唤醒后继节点" class="headerlink" title="AQS.unparkSuccessor : 唤醒后继节点"></a><code>AQS.unparkSuccessor</code> : 唤醒后继节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">	<span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 将节点状态设置为 0</span></span><br><span class="line">		compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	Node s = node.next;</span><br><span class="line">	<span class="comment">// 如果下个节点是 null 或者下个节点被取消</span></span><br><span class="line">	<span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		s = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 从尾部节点开始找, 找到队列第一个正常状态的节点。</span></span><br><span class="line">		<span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">			<span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">				s = t; <span class="comment">// s 为慢指针, 当 t 遍历到 node 的时候, s 就指向 node 下一个有效节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果找到了正常节点便唤醒</span></span><br><span class="line">	<span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">		LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要从后往前找第一个正常状态的节点<ul>
<li>节点入队不是原子操作, 在 <code>addWaiter</code> 方法中先执行 <code>node.prev = pred; compareAndSetTail(pred, node)</code> 将节点入队, 还没执行 <code>pred.next = node;</code>时, 调用 <code>unparkSuccessor</code> 从前往后是找不到这个节点的</li>
<li>在产生 <code>CANCELLED</code> 状态节点的时候, 先断开的是 <code>next</code> 指针, <code>prev</code> 指针并未断开, 因此也是必须要从后往前遍历才能够遍历完全部的节点</li>
</ul>
</li>
</ul>
<h5 id="中断恢复后的执行流程"><a href="#中断恢复后的执行流程" class="headerlink" title="中断恢复后的执行流程"></a>中断恢复后的执行流程</h5><ul>
<li><p>被唤醒的线程处于 <code>parkAndCheckInterrupt</code> 中</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 之前在此处挂起</span></span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回并清除线程的中断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>再回到 <code>acquireQueued</code> 代码, 如果这个时候获取锁成功, 就会把线程的中断状态返回到 <code>acquire</code>,</p>
</li>
<li><p>如果 <code>acquireQueued</code> 返回 <code>true</code>, 就会执行 <code>selfInterrupt</code> 方法</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么获取了锁以后还要中断线程？</p>
<ul>
<li>这部分属于 Java 提供的协作式中断知识内容</li>
<li>当等待线程被唤醒时, 并不知道被唤醒的原因, 可能是当前线程在等待中被中断, 也可能是释放了锁以后被唤醒</li>
<li>因此我们通过 <code>Thread.interrupted()</code> 方法检查中断标记（该方法返回了当前线程的中断状态, 并将当前线程的中断标识设置为 <code>false</code>）, 并记录下来, 如果发现该线程被中断过, 就再中断一次</li>
<li>线程在等待资源的过程中被唤醒, 唤醒后还是会不断地去尝试获取锁, 直到抢到锁为止。也就是说, 在整个流程中, 并不响应中断, 只是记录中断记录。最后抢到锁返回了, 那么如果被中断过的话, 就需要恢复中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Synchronized-和-ReentrantLock-的区别"><a href="#Synchronized-和-ReentrantLock-的区别" class="headerlink" title="Synchronized 和 ReentrantLock 的区别"></a>Synchronized 和 ReentrantLock 的区别</h4><ul>
<li><p>Synchronized 是 JVM 层次的锁实现, ReentrantLock 是 JDK 层次的锁实现</p>
</li>
<li><p>Synchronized 的锁状态是无法在代码中直接判断的, 但是 ReentrantLock 可以通过 <code>ReentrantLock#isLocked</code> 判断</p>
</li>
<li><p>Synchronized 是非公平锁, ReentrantLock 是可以是公平也可以是非公平的</p>
</li>
<li><p>Synchronized 是不可以被中断的, 而 <code>ReentrantLock#lockInterruptibly</code> 方法是可以被中断的</p>
</li>
<li><p>在发生异常时 Synchronized 会自动释放锁（由 javac 编译时自动实现）, 而 ReentrantLock 需要开发者在 finally 块中显示释放锁</p>
</li>
<li><p>ReentrantLock 获取锁的形式有多种：如立即返回是否成功的 tryLock(), 以及等待指定时长的获取, 更加灵活</p>
</li>
<li><p>Synchronized 在特定的情况下<strong>对于已经在等待的线程</strong>是后来的线程先获得锁（上文有说）, 而 ReentrantLock 对于<strong>已经在等待的线程</strong>一定是先来的线程先获得锁</p>
</li>
</ul>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><ul>
<li>Condition 的作用等同于 <code>Object.wait()</code> 和 <code>Object.notify()</code>, 条件队列是一个 FIFO 队列, 可以通过 <code>signalAll</code> 解锁全部的线程, 也可以通过 <code>signal</code> 单独解锁线程, 可以通过如下方式创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br></pre></td></tr></table></figure>

<ul>
<li>Condition 内部也是维护了一个 FIFO 队列 condition queue</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">  <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="awiat-等待-Condition"><a href="#awiat-等待-Condition" class="headerlink" title="awiat : 等待 Condition"></a><code>awiat</code> : 等待 Condition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断中断则抛出 InterruptedException</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 condition queue 中增加节点, 节点状态为 CONDITION, 在增加节点的同时清除掉状态为 CANCELED 的节点</span></span><br><span class="line">  Node node = addConditionWaiter();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放锁并储存释放时的 state, 失败会抛出 IllegalMonitorStateException 异常</span></span><br><span class="line">  <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">  <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断节点是否在同步队列中, 只有不在同步队列, 才阻塞线程</span></span><br><span class="line">  <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 阻塞 node, 直到被 signal 或者中断</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 唤醒后检查中断, 若发生中断则更新节点状态并将其放入同步队列, 并记录对应的中断操作</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当 node 被 signal 或中断后, 已被加入到同步队列中, 调用 acquireQueued 重新获取锁</span></span><br><span class="line">  <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="comment">// 移除掉所有状态为 CANCELED 的节点</span></span><br><span class="line">  <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">  <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 根据 interruptMode 抛出中断异常或恢复中断</span></span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node t = lastWaiter;</span><br><span class="line">  <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">  <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">    unlinkCancelledWaiters(); <span class="comment">// 清理被取消的节点</span></span><br><span class="line">    t = lastWaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">    firstWaiter = node;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    t.nextWaiter = node;</span><br><span class="line">  lastWaiter = node;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node t = firstWaiter;</span><br><span class="line">  Node trail = <span class="keyword">null</span>; <span class="comment">// 慢指针, 指向上个遍历到的有效节点</span></span><br><span class="line">  <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node next = t.nextWaiter;</span><br><span class="line">    <span class="comment">// 如果 t 的状态不是 CONDITION, 则把 t 节点从链表中摘除</span></span><br><span class="line">    <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">      t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = next;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        trail.nextWaiter = next;</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        lastWaiter = trail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      trail = t;</span><br><span class="line">    t = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 从后往前查找节点是否已经在等待队列中</span></span><br><span class="line">  <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node t = tail;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t == node)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t = t.prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">    <span class="comment">// 如果发生中断, 更新节点状态并将其放入同步队列</span></span><br><span class="line">    <span class="comment">// 如果发生在 signal 之前则返回 THROW_IE, 如果中断发生在 signal 之后返回 REINTERRUPT</span></span><br><span class="line">    (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// CAS 成功说明该节点还没被 signal, 将其放入同步队列, 待获取到锁后抛出异常</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 若 CAS 失败则该节点正好被 signal 完, 只需自旋确认节点已经进入同步队列即可, 待获取到锁后恢复异常</span></span><br><span class="line">  <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">    Thread.yield();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="signal-signalAll-通知-Condition"><a href="#signal-signalAll-通知-Condition" class="headerlink" title="signal, signalAll : 通知 Condition"></a><code>signal</code>, <code>signalAll</code> : 通知 Condition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 非持有锁的线程调用会抛出 IllegalMonitorStateException 异常</span></span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="comment">// 取出 condition 队列第一个节点</span></span><br><span class="line">  Node first = firstWaiter;</span><br><span class="line">  <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">    doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  Node first = firstWaiter;</span><br><span class="line">  <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">    doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 向后移动 firstWaiter 指针</span></span><br><span class="line">    <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">      lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">    first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前节点状态并将其放入同步队列</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">           <span class="comment">// 失败时若队列中还有数据则会取下一个继续尝试</span></span><br><span class="line">           (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">  lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    Node next = first.nextWaiter;</span><br><span class="line">    first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    transferForSignal(first);</span><br><span class="line">    first = next;</span><br><span class="line">  &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 节点状态改为 0</span></span><br><span class="line">  <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入同步队列并获得前驱节点</span></span><br><span class="line">  Node p = enq(node);</span><br><span class="line">  <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">  <span class="comment">// 设置前驱节点 waitStatus 为 SIGNAL</span></span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">    <span class="comment">// 前驱节点被取消或设置状态失败, 此时节点已经在同步队列中, 唤醒节点线程往下走同步的逻辑即可</span></span><br><span class="line">    LockSupport.unpark(node.thread);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Condition-的中断处理"><a href="#Condition-的中断处理" class="headerlink" title="Condition 的中断处理"></a>Condition 的中断处理</h4><ul>
<li><code>Condition.await()</code> 跟 <code>Object.wait()</code> 相比, 既有可能抛出 <code>InterruptedException</code> 异常, 也可能恢复中断</li>
<li>处理中断的逻辑是<strong>如果在 <code>signal</code> 之前线程被中断则抛出中断异常, 如果在 <code>signal</code> 之后线程被中断, 则恢复中断, 由调用代码自行处理中断标识</strong></li>
</ul>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><ul>
<li><p><code>ReentrantLock</code> 是独占锁, <code>ReentrantReadWriteLock</code> 是读写锁</p>
</li>
<li><p>读写锁定义：一个资源能够被<strong>多个读线程</strong>访问, 或者被<strong>一个写线程</strong>访问, 但是<strong>不能同时存在读写线程</strong></p>
</li>
<li><p><code>ReentrantReadWriteLock</code> 中读锁为共享锁, 写锁为独占锁</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>); <span class="comment">//共享</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>); <span class="comment">//共享</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>); <span class="comment">//独占</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>); <span class="comment">//独占</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="state-1"><a href="#state-1" class="headerlink" title="state"></a><code>state</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">  <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>state</code> 的高 16 位表示读锁的 state, 低 16 位表示写锁的 state</li>
<li>将两个锁的状态放在同一个 <code>int</code> 变量的中原因是对 <code>state</code> 的操作可以使用 CAS 保证原子性</li>
<li>读锁和写锁最多可以获取 2^16 -1 = 65535 个 (包括重入)</li>
</ul>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><h5 id="加锁过程-3"><a href="#加锁过程-3" class="headerlink" title="加锁过程"></a>加锁过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写锁数量</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 存在读锁或有其他线程持有写锁, 则进入队列等待</span></span><br><span class="line">      <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">      <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 当前线程已持有写锁, 进行重入</span></span><br><span class="line">      <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      <span class="comment">// Reentrant acquire</span></span><br><span class="line">      setState(c + acquires);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否需要排队 (公平锁)</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解锁过程-3"><a href="#解锁过程-3" class="headerlink" title="解锁过程"></a>解锁过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑与 ReentrantLock 相似</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">  <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (free)</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  setState(nextc);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><h5 id="加锁过程-4"><a href="#加锁过程-4" class="headerlink" title="加锁过程"></a>加锁过程</h5><h6 id="AQS-acquireShared-和-AQS-doAcquireShared"><a href="#AQS-acquireShared-和-AQS-doAcquireShared" class="headerlink" title="AQS.acquireShared 和 AQS.doAcquireShared"></a><code>AQS.acquireShared</code> 和 <code>AQS.doAcquireShared</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回值小于 0 代表没有获取到共享锁 (读锁)</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 进入等待</span></span><br><span class="line">    doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新建共享模式节点并进入等待队列</span></span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取前驱节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="comment">// 若为队首节点, 则重新尝试获取共享锁</span></span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 头节点后移并传播</span></span><br><span class="line">          <span class="comment">// 传播即唤醒后面连续的读节点</span></span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          <span class="keyword">if</span> (interrupted)</span><br><span class="line">            <span class="comment">// 等待过程若发生中断则恢复中断</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">// 清理和更新前驱节点状态</span></span><br><span class="line">          parkAndCheckInterrupt()) <span class="comment">// 挂起线程</span></span><br><span class="line">        <span class="comment">// 线程若被中断, 返回 true</span></span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Sync-tryAcquireShared"><a href="#Sync-tryAcquireShared" class="headerlink" title="Sync.tryAcquireShared"></a><code>Sync.tryAcquireShared</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 存在被其他线程持有的写锁, 则进入队列等待</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要排队</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">      <span class="comment">// 开始统计每个读锁获取线程的重入次数</span></span><br><span class="line">      <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 首个获得读锁的线程</span></span><br><span class="line">        firstReader = current;</span><br><span class="line">        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// 首个获得读锁的线程重入</span></span><br><span class="line">        firstReaderHoldCount++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前线程不是第一个获取读锁的线程, 放入该线程的本地变量中</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">          cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">          readHolds.set(rh);</span><br><span class="line">        rh.count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快速获取失败, 进入 TryAcquireShared 完全版本重试</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.apparentlyFirstQueuedIsExclusive</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node h, s;</span><br><span class="line">  <span class="comment">// 在非公平模式, 只有同步队列的首节点是写锁才需要排队</span></span><br><span class="line">  <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    !s.isShared()         &amp;&amp;</span><br><span class="line">    s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TryAcquireShared 完全版本</span></span><br><span class="line"><span class="comment">// 主要为了处理 CAS 失败和 tryAcquireShared 未处理的重入情况</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 部分逻辑与 TryAcquireShared 冗余</span></span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">        <span class="comment">// 若队列中存在获取读锁的情况, 是会走到此位置</span></span><br><span class="line">        <span class="comment">// 检查当前线程是否已持有过读锁</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">          <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">              rh = readHolds.get();</span><br><span class="line">              <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.remove();</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">          firstReader = current;</span><br><span class="line">          firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">          firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">            rh = cachedHoldCounter;</span><br><span class="line">          <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">            readHolds.set(rh);</span><br><span class="line">          rh.count++;</span><br><span class="line">          cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// CAS 失败则重新尝试一遍整个逻辑  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解锁过程-4"><a href="#解锁过程-4" class="headerlink" title="解锁过程"></a>解锁过程</h5><h6 id="AQS-releaseShared-和-AQS-doReleaseShared"><a href="#AQS-releaseShared-和-AQS-doReleaseShared" class="headerlink" title="AQS.releaseShared 和 AQS.doReleaseShared"></a><code>AQS.releaseShared</code> 和 <code>AQS.doReleaseShared</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试释放共享锁</span></span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    <span class="comment">// 共享锁完全释放, 则唤醒队列中的下个节点</span></span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">      <span class="comment">// head state 为 SIGNAL 时唤醒后继节点</span></span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// head state 为 0 时切换状态</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Sync-tryReleaseShared"><a href="#Sync-tryReleaseShared" class="headerlink" title="Sync.tryReleaseShared"></a><code>Sync.tryReleaseShared</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">  Thread current = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 更新线程缓存中的重入次数</span></span><br><span class="line">  <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">    <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">      firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      firstReaderHoldCount--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">      rh = readHolds.get();</span><br><span class="line">    <span class="keyword">int</span> count = rh.count;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      readHolds.remove();</span><br><span class="line">      <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">    &#125;</span><br><span class="line">    --rh.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">      <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">      <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">      <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">      <span class="comment">// 只有读锁数为 0 时才代表完全释放读锁</span></span><br><span class="line">      <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>由获取读锁的逻辑可见, 同一个线程拥有写锁之后再获取读锁是允许的, 这也被称为<strong>锁降级</strong></li>
<li>在非公平锁情况下, 允许写锁插队, 也允许读锁插队, 但是读锁插队的前提是队列中的头节点不能是获取写锁的线程, <strong>避免写线程饥饿</strong></li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li><p><strong>Semaphore (信号量)</strong></p>
<ul>
<li><p>信号量 S, 整型变量, 需要初始化值大于0</p>
</li>
<li><p>P 操作, 原子减少 S, 如果 <code>S &lt; 0</code>, 则阻塞当前线程</p>
</li>
<li><p>V 操作, 原子增加 S, 如果 <code>S &lt;= 0</code>, 则唤醒一个阻塞的线程</p>
</li>
<li><p><a href="https://juejin.im/post/5cb57b79518825327a059ea6" target="_blank" rel="noopener">具体概念请参考该文章</a></p>
</li>
</ul>
</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">      <span class="comment">// state 用于储存信号量</span></span><br><span class="line">      setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">  &#125; </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加锁过程-5"><a href="#加锁过程-5" class="headerlink" title="加锁过程"></a>加锁过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> available = getState();</span><br><span class="line">      <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">      <span class="comment">// 剩余信号量小于 0 直接返回, 线程将进入队列排队</span></span><br><span class="line">      <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">          <span class="comment">// 剩余信号量不小于 0 则成功获取到锁, 更新信号量</span></span><br><span class="line">          compareAndSetState(available, remaining))</span><br><span class="line">        <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 公平锁判断</span></span><br><span class="line">      <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> available = getState();</span><br><span class="line">      <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">          compareAndSetState(available, remaining))</span><br><span class="line">        <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解锁过程-5"><a href="#解锁过程-5" class="headerlink" title="解锁过程"></a>解锁过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> current = getState();</span><br><span class="line">      <span class="comment">// 补回信号量</span></span><br><span class="line">      <span class="keyword">int</span> next = current + releases;</span><br><span class="line">      <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><ul>
<li><p><strong>CountDownLatch (计数闭锁)</strong></p>
<ul>
<li>有初始计数值</li>
<li>计数值大于 0 时, 获取锁的线程会被阻塞</li>
<li>计数值被减到 0 时, 所有被阻塞的线程同时被释放 </li>
</ul>
</li>
<li><p>CountDownLatch 是一种闭锁的实现</p>
<ul>
<li>闭锁可以延迟线程的进度直到其到达终止状态</li>
</ul>
</li>
</ul>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">      <span class="comment">// state 用于储存计数值</span></span><br><span class="line">      setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加锁过程-6"><a href="#加锁过程-6" class="headerlink" title="加锁过程"></a>加锁过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据计数是否到 0 返回是否成功</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解锁过程-6"><a href="#解锁过程-6" class="headerlink" title="解锁过程"></a>解锁过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 计数减 1</span></span><br><span class="line">      <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><ul>
<li>栅栏 (Barrier) 类似于闭锁, 能阻塞一组线程直到某个事件发生<ul>
<li>主要区别在于必须所有线程到达栅栏位置才能继续执行</li>
<li>闭锁用于等待事件, 栅栏用于等待其他线程</li>
</ul>
</li>
</ul>
<h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 用于表示每代栅栏, 并记录该代栅栏是否有被打破</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞所需要</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栅栏的线程数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有线程到达栅栏后会执行的函数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前代</span></span><br><span class="line">  <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于计数, 每有一个到达栅栏的线程就减 1</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="到达栅栏"><a href="#到达栅栏" class="headerlink" title="到达栅栏"></a>到达栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">				 BrokenBarrierException,</span></span><br><span class="line"><span class="function">				 TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">							 TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (g.broken)</span><br><span class="line">      <span class="comment">// 若此代栅栏已经被打破, 则抛出 BrokenBarrierException 异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      <span class="comment">// 处理中断, 打破栅栏</span></span><br><span class="line">      breakBarrier();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数减 1</span></span><br><span class="line">    <span class="keyword">int</span> index = --count;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">      <span class="comment">// 计数到 0 时代表所有线程都已经到达栅栏</span></span><br><span class="line">      <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行栅栏函数</span></span><br><span class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">          command.run();</span><br><span class="line">        ranAction = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 开始下一代栅栏</span></span><br><span class="line">        nextGeneration();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ranAction)</span><br><span class="line">          breakBarrier();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数未到 0, 进行阻塞等待</span></span><br><span class="line">    <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timed)</span><br><span class="line">          trip.await();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">          nanos = trip.awaitNanos(nanos);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">          breakBarrier();</span><br><span class="line">          <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">          <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">          <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g.broken)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g != generation)</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待超时, 打破栅栏</span></span><br><span class="line">        breakBarrier();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写一致性的一些思考"><a href="#读写一致性的一些思考" class="headerlink" title="读写一致性的一些思考"></a>读写一致性的一些思考</h3><ul>
<li><p>在<strong>一个线程写，一个或多个线程读</strong>的情况下</p>
</li>
<li><p>试想下这样一个场景：一个线程往 HashMap 中写数据，一个线程往 HashMap 中读数据。 这样会有问题吗？</p>
<ol>
<li><p>内存可见性的问题，HashMap 存储数据的 <code>table</code> 并没有用 <code>voliate</code> 修饰，也就是说读线程可能一直读不到数据的最新值</p>
</li>
<li><p>指令重排序的问题，<code>get</code> 的时候可能得到的是一个中间状态的数据，我们看下 <code>put</code> 方法的部分代码</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>put</code> 操作时，如果 <code>table</code> 数组的指定位置为 <code>null</code>，会创建一个 <code>Node</code> 对象，并放到 <code>table</code> 数组上</p>
</li>
<li><p>JVM 中 <code>tab[i] = new Node&lt;&gt;(hash, key, value, next);</code> 这样的操作不是原子的，并且可能因为指令重排序，导致另一个线程调用 <code>get</code> 取 <code>tab[i]</code> 的时候，拿到的是一个还没有调用完构造方法的对象，导致不可预料的问题发生</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>上述的两个问题可以说都是因为 HashMap 中的内部属性没有被 <code>voliate</code> 修饰导致的</p>
<ul>
<li>就算给 <code>table</code> 加上了 <code>volatile</code> 应该只是保持了 <code>table</code> 引用的可见性，对于 <code>table</code> 中的元素不起作用</li>
<li>所以 <code>table</code> 加上<code>volatile</code> 也不能保证其中元素的可见性</li>
<li>在 ConcurrentHashMap (1.8) 中<ul>
<li>通过 <code>Unsafe</code> 类的 <code>getObjectVolatile</code> 方法保证 <code>table</code> 里获取到的数据每次都是最新的，而不是缓存</li>
<li>而在设置数组元素时, 采用 <code>compareAndSwapObject</code> 方法，而不是直接通过下标去操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="创建对象的原子性问题"><a href="#创建对象的原子性问题" class="headerlink" title="创建对象的原子性问题"></a>创建对象的原子性问题</h4><ul>
<li><p>对于 <code>Object obj = new Object();</code>这样的操作, 在多线程的情况下可能会拿到一个未初始化的对象</p>
</li>
<li><p>以上 Java 语句分为 4 个步骤</p>
<ol>
<li>在栈中分配一片空间给 <code>obj</code> 引用</li>
<li>在 JVM 堆中创建一个 <code>Object</code> 对象，注意这里仅仅是分配空间，没有调用构造方法</li>
<li>初始化第 2 步创建的对象，也就是调用其构造方法</li>
<li>栈中的 <code>obj</code> 指向堆中的对象</li>
</ol>
</li>
<li><p>问题在于 JVM 是会对指令进行<a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">重排序</a>的，重排之后可能是第 4 步先于第 3 步执行，那这时候另外一个线程读到的就是没有还执行构造方法的对象，导致未知问题</p>
</li>
<li><p>JVM 重排只保证重排前和重排后在<strong>单线程</strong>中的结果一致性</p>
</li>
<li><p>注意 Java 中引用的赋值操作一定是原子的，比如说 a 和 b 均是对象的情况下不管是 32 位还是 64 位 JVM，<code>a=b</code> 操作均是原子的</p>
<ul>
<li>但如果 a 和 b 是 <code>long</code> 或者 <code>double</code> 原子型数据，那在 32 位 JVM 上 <code>a=b</code> 不一定是原子的（看 JVM 具体实现），有可能是分成了两个 32 位操作。 但是对于 <code>voliate</code> 的 <code>long</code>, <code>double</code> 变量来说，其赋值是原子的</li>
</ul>
</li>
</ul>
<h4 id="数据库中读写一致性"><a href="#数据库中读写一致性" class="headerlink" title="数据库中读写一致性"></a>数据库中读写一致性</h4><ul>
<li><p>跳出 HashMap，在数据库中都是要用 <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">MVCC 机制</a>避免加读写锁</p>
</li>
<li><p>也就是说如果不用 MVCC，数据库是要加读写锁的，那为什么数据库要加读写锁呢？</p>
<ul>
<li>原因是写操作不是原子的，如果不加读写锁或 MVCC，可能会读到中间状态的数据</li>
<li>以 HBase 为例，Hbase 写流程分为以下几个步骤：<ol>
<li>获得行锁</li>
<li>开启 MVCC</li>
<li>写到内存 Buffer</li>
<li>写到 Append Log</li>
<li>释放行锁</li>
<li>Flush Log</li>
<li>MVCC 结束（这时才对读可见）</li>
</ol>
</li>
<li>试想，如果没有不走 2，7 也不加读写锁，那在步骤 3 的时候，其他的线程就能读到该数据</li>
<li>如果说 3 之后出现了问题，那该条数据其实是写失败的。也就是说其他线程曾经读到过不存在的数据</li>
</ul>
</li>
<li><p>同理，在 MySQL 中，如果不用 MVCC 也不用读写锁，一个事务还没 commit，其中的数据就能被读到，如果用读写锁，一个事务会对中更改的数据加写锁，这时其他读操作会阻塞，直到事务提交，对于性能有很大的影响，所以大多数情况下数据库都采用 MVCC 机制实现非锁定读</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.jianshu.com/p/8601f374f051" target="_blank" rel="noopener">https://www.jianshu.com/p/8601f374f051</a></p>
<p><a href="https://www.jianshu.com/p/1708ccfb07ae" target="_blank" rel="noopener">https://www.jianshu.com/p/1708ccfb07ae</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52563959" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52563959</a></p>
<p><a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">https://github.com/farmerjohngit/myblog/issues/12</a></p>
<p><a href="https://tech.meituan.com/2018/11/15/Java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/Java-lock.html</a></p>
<p><a href="https://juejin.im/post/5e0b02436fb9a0483040c522#heading-16" target="_blank" rel="noopener">https://juejin.im/post/5e0b02436fb9a0483040c522#heading-16</a></p>
<p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p>
<p><a href="https://github.com/farmerjohngit/myblog/issues/9" target="_blank" rel="noopener">https://github.com/farmerjohngit/myblog/issues/9</a></p>
</blockquote>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/multithread/" rel="tag"># multithread</a>
          
            <a href="/tags/concurrency/" rel="tag"># concurrency</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/20/Java-线程与线程池/" rel="next" title="Java 线程与线程池">
                <i class="fa fa-chevron-left"></i> Java 线程与线程池
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/28/Java-垃圾回收与引用/" rel="prev" title="Java 垃圾回收">
                Java 垃圾回收 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Chaosn Chan">
            
              <p class="site-author-name" itemprop="name">Chaosn Chan</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/chenchensheng" title="GitHub &rarr; https://github.com/chenchensheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:330266801@qq.com" title="E-Mail &rarr; mailto:330266801@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-线程同步与锁"><span class="nav-number">1.</span> <span class="nav-text">Java 线程同步与锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#锁的相关概念"><span class="nav-number">1.1.</span> <span class="nav-text">锁的相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按照其性质分类"><span class="nav-number">1.1.1.</span> <span class="nav-text">按照其性质分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公平锁-非公平锁"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">公平锁, 非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#公平锁"><span class="nav-number">1.1.1.1.1.</span> <span class="nav-text">公平锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非公平锁"><span class="nav-number">1.1.1.1.2.</span> <span class="nav-text">非公平锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观锁-乐观锁"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">悲观锁, 乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#悲观锁"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#乐观锁"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CAS"><span class="nav-number">1.1.1.2.2.1.</span> <span class="nav-text">CAS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入锁"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#独享锁-排他锁-共享锁-互斥锁-读写锁"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">独享锁 (排他锁), 共享锁, 互斥锁, 读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#独享锁"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">独享锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#共享锁"><span class="nav-number">1.1.1.4.2.</span> <span class="nav-text">共享锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按照设计方案来分类"><span class="nav-number">1.1.2.</span> <span class="nav-text">按照设计方案来分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自旋锁-适应性自旋锁"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">自旋锁, 适应性自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#自旋锁"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#适应性自旋锁"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">适应性自旋锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁粗化-锁消除"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">锁粗化, 锁消除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#锁粗化"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">锁粗化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁消除"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">锁消除</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分段锁"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">分段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无锁-偏向锁-轻量级锁-重量级锁"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">无锁, 偏向锁, 轻量级锁, 重量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#无锁"><span class="nav-number">1.1.2.4.1.</span> <span class="nav-text">无锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#偏向锁"><span class="nav-number">1.1.2.4.2.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#轻量级锁"><span class="nav-number">1.1.2.4.3.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重量级锁"><span class="nav-number">1.1.2.4.4.</span> <span class="nav-text">重量级锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考-如何实现锁"><span class="nav-number">1.2.</span> <span class="nav-text">思考: 如何实现锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋"><span class="nav-number">1.2.1.</span> <span class="nav-text">自旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield-自旋"><span class="nav-number">1.2.2.</span> <span class="nav-text">yield + 自旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-自旋"><span class="nav-number">1.2.3.</span> <span class="nav-text">sleep + 自旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#park-自旋"><span class="nav-number">1.2.4.</span> <span class="nav-text">park + 自旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于锁冲突不严重的情况-用自旋锁会更适合"><span class="nav-number">1.2.5.</span> <span class="nav-text">对于锁冲突不严重的情况, 用自旋锁会更适合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-如何实现锁"><span class="nav-number">1.3.</span> <span class="nav-text">linux 如何实现锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#futex-诞生之前"><span class="nav-number">1.3.1.</span> <span class="nav-text">futex 诞生之前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#futex-诞生之后"><span class="nav-number">1.3.2.</span> <span class="nav-text">futex 诞生之后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-如何实现锁"><span class="nav-number">1.4.</span> <span class="nav-text">Java 如何实现锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">1.4.1.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象头"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重量级锁-1"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级锁-1"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#加锁过程"><span class="nav-number">1.4.1.3.1.</span> <span class="nav-text">加锁过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解锁过程"><span class="nav-number">1.4.1.3.2.</span> <span class="nav-text">解锁过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁-1"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象创建"><span class="nav-number">1.4.1.4.1.</span> <span class="nav-text">对象创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加锁过程-1"><span class="nav-number">1.4.1.4.2.</span> <span class="nav-text">加锁过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解锁过程-1"><span class="nav-number">1.4.1.4.3.</span> <span class="nav-text">解锁过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#批量重偏向与撤销"><span class="nav-number">1.4.1.4.4.</span> <span class="nav-text">批量重偏向与撤销</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁状态转换流程"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">锁状态转换流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">1.4.2.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#架构图"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">架构图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#state"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在-JUC-中的应用"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">在 JUC 中的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LockSupport"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">LockSupport</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#成员变量"><span class="nav-number">1.4.2.5.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#park-方法"><span class="nav-number">1.4.2.5.2.</span> <span class="nav-text">park 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.4.3.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加锁过程-2"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">加锁过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock-lock-开始加锁操作"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">ReentrantLock.lock : 开始加锁操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS-acquire"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">AQS.acquire</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#tryAcquire-尝试获取锁并更新-state"><span class="nav-number">1.4.3.2.2.1.</span> <span class="nav-text">tryAcquire : 尝试获取锁并更新 state</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#addWaiter-获取锁失败后把线程放入等待队列"><span class="nav-number">1.4.3.2.2.2.</span> <span class="nav-text">addWaiter : 获取锁失败后把线程放入等待队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#acquireQueued-队列中的节点不断尝试获取锁"><span class="nav-number">1.4.3.2.2.3.</span> <span class="nav-text">acquireQueued :  队列中的节点不断尝试获取锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流程图"><span class="nav-number">1.4.3.2.3.</span> <span class="nav-text">流程图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解锁过程-2"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">解锁过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock-unlock-AQS-release-开始解锁操作"><span class="nav-number">1.4.3.3.1.</span> <span class="nav-text">ReentrantLock.unlock, AQS.release : 开始解锁操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sync-tryRelease-尝试解锁并更新-state"><span class="nav-number">1.4.3.3.2.</span> <span class="nav-text">Sync.tryRelease : 尝试解锁并更新 state</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS-unparkSuccessor-唤醒后继节点"><span class="nav-number">1.4.3.3.3.</span> <span class="nav-text">AQS.unparkSuccessor : 唤醒后继节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中断恢复后的执行流程"><span class="nav-number">1.4.3.3.4.</span> <span class="nav-text">中断恢复后的执行流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-和-ReentrantLock-的区别"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">Synchronized 和 ReentrantLock 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#awiat-等待-Condition"><span class="nav-number">1.4.3.5.1.</span> <span class="nav-text">awiat : 等待 Condition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#signal-signalAll-通知-Condition"><span class="nav-number">1.4.3.5.2.</span> <span class="nav-text">signal, signalAll : 通知 Condition</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition-的中断处理"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">Condition 的中断处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">1.4.4.</span> <span class="nav-text">ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#state-1"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写锁"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#加锁过程-3"><span class="nav-number">1.4.4.2.1.</span> <span class="nav-text">加锁过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解锁过程-3"><span class="nav-number">1.4.4.2.2.</span> <span class="nav-text">解锁过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读锁"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">读锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#加锁过程-4"><span class="nav-number">1.4.4.3.1.</span> <span class="nav-text">加锁过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AQS-acquireShared-和-AQS-doAcquireShared"><span class="nav-number">1.4.4.3.1.1.</span> <span class="nav-text">AQS.acquireShared 和 AQS.doAcquireShared</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Sync-tryAcquireShared"><span class="nav-number">1.4.4.3.1.2.</span> <span class="nav-text">Sync.tryAcquireShared</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解锁过程-4"><span class="nav-number">1.4.4.3.2.</span> <span class="nav-text">解锁过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AQS-releaseShared-和-AQS-doReleaseShared"><span class="nav-number">1.4.4.3.2.1.</span> <span class="nav-text">AQS.releaseShared 和 AQS.doReleaseShared</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Sync-tryReleaseShared"><span class="nav-number">1.4.4.3.2.2.</span> <span class="nav-text">Sync.tryReleaseShared</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">1.4.4.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.4.5.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加锁过程-5"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">加锁过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解锁过程-5"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">解锁过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">1.4.6.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化-1"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加锁过程-6"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">加锁过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解锁过程-6"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">解锁过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">1.4.7.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化-2"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#到达栅栏"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">到达栅栏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写一致性的一些思考"><span class="nav-number">1.4.8.</span> <span class="nav-text">读写一致性的一些思考</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建对象的原子性问题"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">创建对象的原子性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库中读写一致性"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">数据库中读写一致性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">2.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chaosn Chan</span>

  

  
</div>









<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count"> 全站共 89.7k 字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  
    <!-- LOCAL: You can save these files to your site and update links -->

  
  <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitmint.browser.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css">
<!-- END LOCAL -->

<script>
  function renderGitment() {
    var gitment = new Gitmint({
      id: window.location.pathname
      owner: 'chenchensheng',
      repo: 'chanson.github.io',
      
        lang: '' || navigator.language || navigator.systemLanguage || navigator.userLanguage,
      
      oauth: {
      
      
        client_secret: '414f1aaca1a5baf17fb9929bb9e864be3978061f',
      
        client_id: '46aed381471ff9cef5d8'
      }
    });
    gitment.render('gitment-container');
  }

  
    renderGitment();
  
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
