<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Docker 基础 Namespace 进程之间的可见性   Cgoups 限制资源的使用    K8s 基础组件  Kubernetes 主要由以下几个核心组件组成:  master 组件, 可以运行于集群中的任何机器上, 但为了简洁性通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器 kube-apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制">
<meta name="keywords" content="k8s">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes 学习笔记">
<meta property="og:url" content="https://chansonchan.cn/2020/02/12/Kubernetes-学习笔记/index.html">
<meta property="og:site_name" content="Chanson">
<meta property="og:description" content="Docker 基础 Namespace 进程之间的可见性   Cgoups 限制资源的使用    K8s 基础组件  Kubernetes 主要由以下几个核心组件组成:  master 组件, 可以运行于集群中的任何机器上, 但为了简洁性通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器 kube-apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/k8s-basic.png">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/services-userspace-overview.7dfebdc9.svg">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/services-iptables-overview.fc39e9e4.svg">
<meta property="og:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/services-ipvs-overview.25df78cc.svg">
<meta property="og:updated_time" content="2020-09-14T02:39:20.969Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kubernetes 学习笔记">
<meta name="twitter:description" content="Docker 基础 Namespace 进程之间的可见性   Cgoups 限制资源的使用    K8s 基础组件  Kubernetes 主要由以下几个核心组件组成:  master 组件, 可以运行于集群中的任何机器上, 但为了简洁性通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器 kube-apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制">
<meta name="twitter:image" content="https://gitee.com/chansonchan/image/raw/master/uPic/k8s-basic.png">





  
  
  <link rel="canonical" href="https://chansonchan.cn/2020/02/12/Kubernetes-学习笔记/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Kubernetes 学习笔记 | Chanson</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chanson</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chansonchan.cn/2020/02/12/Kubernetes-学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chaosn Chan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chanson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kubernetes 学习笔记

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-02-12 20:00:00" itemprop="dateCreated datePublished" datetime="2020-02-12T20:00:00+08:00">2020-02-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-09-14 10:39:20" itemprop="dateModified" datetime="2020-09-14T10:39:20+08:00">2020-09-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/devops/" itemprop="url" rel="index"><span itemprop="name">devops</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Docker-基础"><a href="#Docker-基础" class="headerlink" title="Docker 基础"></a>Docker 基础</h1><ul>
<li>Namespace<ul>
<li>进程之间的可见性</li>
</ul>
</li>
<li>Cgoups<ul>
<li>限制资源的使用</li>
</ul>
</li>
</ul>
<h1 id="K8s-基础"><a href="#K8s-基础" class="headerlink" title="K8s 基础"></a>K8s 基础</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://gitee.com/chansonchan/image/raw/master/uPic/k8s-basic.png" alt="k8s-basic"></p>
<ul>
<li><p>Kubernetes 主要由以下几个核心组件组成:</p>
<ul>
<li><strong>master 组件</strong>, 可以运行于集群中的任何机器上, 但为了简洁性通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器<ul>
<li><strong>kube-apiserver</strong> 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</li>
<li><strong>etcd</strong> 保存了整个集群的状态，就是一个数据库</li>
<li><strong>kube-scheduler</strong> 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</li>
<li><strong>kube-controller-manager</strong> 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等</li>
<li><strong>cloud-controller-manager</strong> 运行了与具体云基础设施供应商互动的控制器</li>
</ul>
</li>
<li><strong>node 组件</strong>, 运行在每一个节点上（包括 master 节点和 worker 节点），负责维护运行中的 Pod 并提供 K8s 运行时环境<ul>
<li><strong>kubelet</strong> 负责维护容器的生命周期，同时也负责 Volume（CSI）和网络（CNI）的管理</li>
<li><strong>kube-proxy</strong> 负责为 Service 提供 cluster 内部的服务发现和负载均衡</li>
<li><strong>container runtime</strong> 负责镜像管理以及 Pod 和容器的真正运行（CRI）</li>
</ul>
</li>
</ul>
</li>
<li><p>除了上面的这些核心组件，还有一些推荐的插件：</p>
<ul>
<li><strong>DNS</strong> 负责为整个集群提供 DNS 服务</li>
<li><strong>Ingress Controller</strong> 为服务提供外网入口</li>
<li><strong>Heapster</strong> 提供资源监控</li>
<li><strong>Dashboard</strong> 提供 GUI</li>
</ul>
</li>
<li><p>Kubernetes 多组件之间的通信原理</p>
<ul>
<li>apiserver 负责 etcd 存储的所有操作，且<strong>只有 apiserver 才直接操作 etcd 集群</strong></li>
<li>apiserver 对内（集群中的其他组件）和对外（用户）提供统一的 REST API，其他组件均通过 apiserver 进行通信<ul>
<li>controller manager、scheduler、kube-proxy 和 kubelet 等均通过 apiserver watch API 监测资源变化情况，并对资源作相应的操作</li>
<li>所有需要更新资源状态的操作均通过 apiserver 的 REST API 进行</li>
</ul>
</li>
<li>apiserver 也会直接调用 kubelet API（如 logs, exec, attach 等），默认不校验 kubelet 证书，但可以通过 <code>--kubelet-certificate-authority</code> 开启（而 GKE 通过 SSH 隧道保护它们之间的通信）</li>
</ul>
</li>
<li><p>比如最典型的创建 Pod 的流程：</p>
<ul>
<li>用户通过 REST API 创建一个 Pod</li>
<li>apiserver 将其写入 etcd</li>
<li>scheduluer 检测到未绑定 Node 的 Pod，开始调度并更新 Pod 的 Node 绑定</li>
<li>kubelet 检测到有新的 Pod 调度过来，通过 container runtime 运行该 Pod</li>
<li>kubelet 通过 container runtime 取到 Pod 状态，并更新到 apiserver 中</li>
</ul>
</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><ul>
<li><p>执行以下命令可查看节点状态以及节点的其他详细信息</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Name:               demo-worker-temp-01</span><br><span class="line">Roles:              &lt;none&gt;</span><br><span class="line">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class="line">                    beta.kubernetes.io/os=linux</span><br><span class="line">                    kubernetes.io/arch=amd64</span><br><span class="line">                    kubernetes.io/hostname=demo-worker-temp-01</span><br><span class="line">                    kubernetes.io/os=linux</span><br><span class="line">Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock</span><br><span class="line">                    node.alpha.kubernetes.io/ttl: 0</span><br><span class="line">                    projectcalico.org/IPv4Address: 172.17.216.105/20</span><br><span class="line">                    projectcalico.org/IPv4IPIPTunnelAddr: 192.168.199.128</span><br><span class="line">                    volumes.kubernetes.io/controller-managed-attach-detach: <span class="literal">true</span></span><br><span class="line">CreationTimestamp:  Mon, 30 Sep 2019 06:30:16 +0800</span><br><span class="line">Taints:             &lt;none&gt;</span><br><span class="line">Unschedulable:      <span class="literal">false</span></span><br><span class="line">Conditions:</span><br><span class="line">  Type                 Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----                 ------  -----------------                 ------------------                ------                       -------</span><br><span class="line">  NetworkUnavailable   False   Wed, 02 Oct 2019 22:37:33 +0800   Wed, 02 Oct 2019 22:37:33 +0800   CalicoIsUp                   Calico is running on this node</span><br><span class="line">  MemoryPressure       False   Sun, 06 Oct 2019 13:44:41 +0800   Mon, 30 Sep 2019 06:30:16 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available</span><br><span class="line">  DiskPressure         False   Sun, 06 Oct 2019 13:44:41 +0800   Mon, 30 Sep 2019 06:30:16 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure</span><br><span class="line">  PIDPressure          False   Sun, 06 Oct 2019 13:44:41 +0800   Mon, 30 Sep 2019 06:30:16 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available</span><br><span class="line">  Ready                True    Sun, 06 Oct 2019 13:44:41 +0800   Wed, 02 Oct 2019 22:37:41 +0800   KubeletReady                 kubelet is posting ready status</span><br><span class="line">Addresses:</span><br><span class="line">  InternalIP:  172.17.216.105</span><br><span class="line">  Hostname:    demo-worker-temp-01</span><br><span class="line">Capacity:</span><br><span class="line"> cpu:                2</span><br><span class="line"> ephemeral-storage:  41147472Ki</span><br><span class="line"> hugepages-1Gi:      0</span><br><span class="line"> hugepages-2Mi:      0</span><br><span class="line"> memory:             7733524Ki</span><br><span class="line"> pods:               110</span><br><span class="line">Allocatable:</span><br><span class="line"> cpu:                2</span><br><span class="line"> ephemeral-storage:  37921510133</span><br><span class="line"> hugepages-1Gi:      0</span><br><span class="line"> hugepages-2Mi:      0</span><br><span class="line"> memory:             7631124Ki</span><br><span class="line"> pods:               110</span><br><span class="line">System Info:</span><br><span class="line"> Machine ID:                 20190711105006363114529432776998</span><br><span class="line"> System UUID:                841EC123-F92C-4A3A-BEC0-DAADDD625067</span><br><span class="line"> Boot ID:                    70c08b02-45ed-456f-8deb-b5c0ebeab414</span><br><span class="line"> Kernel Version:             3.10.0-957.21.3.el7.x86_64</span><br><span class="line"> OS Image:                   CentOS Linux 7 (Core)</span><br><span class="line"> Operating System:           linux</span><br><span class="line"> Architecture:               amd64</span><br><span class="line"> Container Runtime Version:  docker://18.9.7</span><br><span class="line"> Kubelet Version:            v1.16.0</span><br><span class="line"> Kube-Proxy Version:         v1.16.0</span><br><span class="line">Non-terminated Pods:         (21 <span class="keyword">in</span> total)</span><br><span class="line">  Namespace                  Name                                        CPU Requests  CPU Limits  Memory Requests  Memory Limits  AGE</span><br><span class="line">  ---------                  ----                                        ------------  ----------  ---------------  -------------  ---</span><br><span class="line">  default                    nginx-deployment-5754944d6c-8lnlx           0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d14h</span><br><span class="line">  example                    gateway-example-6f6f45cd6-mhggv             0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d14h</span><br><span class="line">  example                    monitor-grafana-ff99b5b6f-sxppz             0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d14h</span><br><span class="line">  kube-system                calico-node-qjfqd                           250m (12%)    0 (0%)      0 (0%)           0 (0%)         6d7h</span><br><span class="line">  kube-system                eip-nfs-cluster-storage-6c9c7d46f4-lmxql    0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d14h</span><br><span class="line">  kube-system                kube-proxy-4xz9h                            0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d15h</span><br><span class="line">  kube-system                monitor-prometheus-node-exporter-t7d24      0 (0%)        0 (0%)      0 (0%)           0 (0%)         2d20h</span><br><span class="line">  kuboard-blog               cloud-busybox-867645c5dd-7l97b              0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d14h</span><br><span class="line">  kuboard-blog               db-wordpress-79d88d66b7-j7kj8               0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d14h</span><br><span class="line">  kuboard-press              svc-busybox-6cc877b848-2kl28                0 (0%)        0 (0%)      0 (0%)           0 (0%)         3d14h</span><br><span class="line">  kuboard-press              web-kuboard-press-6d6f8bdbb8-c4q44          0 (0%)        0 (0%)      0 (0%)           0 (0%)         2d3h</span><br><span class="line">  nginx-ingress              nginx-ingress-hsv26                         0 (0%)        0 (0%)      0 (0%)           0 (0%)         6d7h</span><br><span class="line">Allocated resources:</span><br><span class="line">  (Total limits may be over 100 percent, i.e., overcommitted.)</span><br><span class="line">  Resource           Requests    Limits</span><br><span class="line">  --------           --------    ------</span><br><span class="line">  cpu                250m (12%)  0 (0%)</span><br><span class="line">  memory             0 (0%)      0 (0%)</span><br><span class="line">  ephemeral-storage  0 (0%)      0 (0%)</span><br><span class="line">Events:              &lt;none&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h5><ul>
<li>HostName<ul>
<li>在节点命令行界面上执行 <code>hostname</code> 命令所获得的值</li>
<li>启动 kubelet 时，可以通过参数 <code>--hostname-override</code> 覆盖</li>
</ul>
</li>
<li>ExternalIP：通常是节点的外部IP（可以从集群外访问的内网IP地址；上面的例子中，此字段为空）</li>
<li>InternalIP：通常是从节点内部可以访问的 IP 地址</li>
</ul>
<h5 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h5><table>
<thead>
<tr>
<th>Node Condition</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OutOfDisk</td>
<td>如果节点上的空白磁盘空间不够，不能够再添加新的节点时，该字段为 <code>True</code>，其他情况为 <code>False</code></td>
</tr>
<tr>
<td>Ready</td>
<td>如果节点是健康的且已经就绪可以接受新的 Pod。则节点Ready字段为 <code>True</code>。<code>False</code>表明了该节点不健康，不能够接受新的 Pod。</td>
</tr>
<tr>
<td>MemoryPressure</td>
<td>如果节点内存紧张，则该字段为 <code>True</code>，否则为<code>False</code></td>
</tr>
<tr>
<td>PIDPressure</td>
<td>如果节点上进程过多，则该字段为 <code>True</code>，否则为 <code>False</code></td>
</tr>
<tr>
<td>DiskPressure</td>
<td>如果节点磁盘空间紧张，则该字段为 <code>True</code>，否则为 <code>False</code></td>
</tr>
<tr>
<td>NetworkUnvailable</td>
<td>如果节点的网络配置有问题，则该字段为 <code>True</code>，否则为 <code>False</code></td>
</tr>
</tbody></table>
<ul>
<li><p>如果 <code>Ready</code> 类型 Condition 的 <code>status</code> 持续为 <code>Unkown</code> 或者 <code>False</code> 超过 <code>pod-eviction-timeout</code>（<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>的参数）所指定的时间 (默认 5 分钟)，节点控制器（node controller）将对该节点上的所有 Pod 执行删除的调度动作</p>
</li>
<li><p>某些情况下（例如，节点网络故障），apiserver 不能够与节点上的 kubelet 通信，直到通信重新建立，删除 Pod 的指令才会下达到节点</p>
</li>
</ul>
<h5 id="Capacity-and-Allocatable"><a href="#Capacity-and-Allocatable" class="headerlink" title="Capacity and Allocatable"></a>Capacity and Allocatable</h5><ul>
<li><p>CPU</p>
</li>
<li><p>内存</p>
</li>
<li><p>该节点可调度的最大 pod 数量</p>
</li>
<li><p>Capacity 中的字段表示节点上的资源总数，Allocatable 中的字段表示该节点上可分配给普通 Pod 的资源总数</p>
</li>
</ul>
<h5 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h5><ul>
<li>Linux 内核版本</li>
<li>Kubernetes 版本（kubelet 和 kube-proxy 的版本）</li>
<li>Docker 版本</li>
<li>操作系统名称</li>
<li>这些信息由节点上的 kubelet 收集</li>
</ul>
<h4 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h4><ul>
<li>节点不是由 Kubernetes 创建的, 向 Kubernetes 中创建节点时，仅仅是创建了一个描述该节点的 API 对象</li>
<li>Kubernetes 在 APIServer 上创建一个节点 API 对象（节点的描述），并且基于 <code>metadata.name</code> 字段对节点进行健康检查</li>
<li>如果节点有效（节点组件正在运行），则可以向该节点调度 Pod；否则，该节点 API 对象将被忽略，直到节点变为有效状态</li>
</ul>
<h5 id="节点控制器"><a href="#节点控制器" class="headerlink" title="节点控制器"></a>节点控制器</h5><p>节点控制器是一个负责管理节点的 Kubernetes master 组件</p>
<ul>
<li><p>在注册节点时为节点分配 <a href="https://kuboard.cn/glossary/cidr.html" target="_blank" rel="noopener">CIDR</a> 地址块</p>
</li>
<li><p>通过云供应商（<a href="https://kuboard.cn/learning/k8s-bg/component.html#cloud-controller-manager" target="_blank" rel="noopener">cloud-controller-manager</a>）接口检查每一个节点对象对应的虚拟机是否可用</p>
<ul>
<li>在云环境中，只要节点状态异常，节点控制器检查其虚拟机在云供应商的状态，如果虚拟机不可用，自动将节点对象从 APIServer 中删除</li>
</ul>
</li>
<li><ul>
<li><p>当节点变得不可触达时（例如，由于节点已停机，节点控制器不再收到来自节点的心跳信号），节点控制器将节点API对象的 <code>NodeStatus</code> Condition 取值从 <code>NodeReady</code> 更新为 <code>Unknown</code></p>
</li>
<li><p>然后在等待 <code>pod-eviction-timeout</code> 时间后，将节点上的所有 Pod 从节点驱逐</p>
</li>
<li><blockquote>
<ul>
<li>默认40秒未收到心跳，修改 <code>NodeStatus</code> Condition 为 <code>Unknown</code></li>
<li>默认 <code>pod-eviction-timeout</code> 为 5分钟</li>
<li>节点控制器每隔 <code>--node-monitor-period</code> 秒检查一次节点的状态</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="节点自注册"><a href="#节点自注册" class="headerlink" title="节点自注册"></a>节点自注册</h5><p>如果 kubelet 的启动参数 <code>--register-node</code>为 true（默认为 true），kubelet 会尝试将自己注册到 API Server。kubelet自行注册时，将使用如下选项：</p>
<ul>
<li><code>--kubeconfig</code>：向 apiserver 进行认证时所用身份信息的路径</li>
<li><code>--cloud-provider</code>：向云供应商读取节点自身元数据</li>
<li><code>--register-node</code>：自动向 API Server 注册节点</li>
<li><code>--register-with-taints</code>：注册节点时，为节点添加污点（逗号分隔，格式为 <key>=<value>:<effect></effect></value></key></li>
<li><code>--node-ip</code>：节点的 IP 地址</li>
<li><code>--node-labels</code>：注册节点时，为节点添加标签</li>
<li><code>--node-status-update-frequency</code>：向 master 节点发送心跳信息的时间间隔</li>
</ul>
<h5 id="手动管理节点"><a href="#手动管理节点" class="headerlink" title="手动管理节点"></a>手动管理节点</h5><ul>
<li><p>如果管理员想要手工创建节点 API 对象，可以将 kubelet 的启动参数 <code>--register-node</code> 设置为 false</p>
</li>
<li><p>管理员可以修改节点 API 对象（不管是否设置了 <code>--register-node</code> 参数）</p>
<ul>
<li><p>增加 / 减少标签</p>
<ul>
<li>节点的标签与 Pod 上的节点选择器（node selector）配合，可以控制调度方式，例如限定 Pod 只能在某一组节点上运行</li>
</ul>
</li>
<li><p>标记节点为不可调度（unschedulable）</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon <span class="variable">$NODENAME</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此时将阻止新的 Pod 被调度到该节点上，但是不影响任何已经在该节点上运行的 Pod</p>
</li>
<li><p>DaemonSet Controller 创建的 Pod 将绕过 Kubernetes 调度器，并且忽略节点的 unschedulable 属性</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="节点容量"><a href="#节点容量" class="headerlink" title="节点容量"></a>节点容量</h5><ul>
<li>节点 API 对象中描述了节点的容量（Capacity），例如，CPU数量、内存大小等信息</li>
<li>通常，节点在向 APIServer 注册的同时，在节点 API 对象里汇报了其容量（Capacity）</li>
<li>如果是手工创建节点 API 对象, 需要在添加节点时自己设置节点的容量</li>
</ul>
<h3 id="集群内的通信"><a href="#集群内的通信" class="headerlink" title="集群内的通信"></a>集群内的通信</h3><h4 id="Cluster-to-Master"><a href="#Cluster-to-Master" class="headerlink" title="Cluster to Master"></a>Cluster to Master</h4><ul>
<li><p>所有从集群访问 Master 节点的通信，都是针对 apiserver 的（没有任何其他 master 组件发布远程调用接口）</p>
</li>
<li><p>通常安装 Kubernetes 时，apiserver 监听 HTTPS 端口（443），并且配置了一种或多种 <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">客户端认证方式 authentication</a></p>
<ul>
<li>至少需要配置一种形式的 <a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">授权方式 authorization</a>，尤其是 <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#anonymous-requests" target="_blank" rel="noopener">匿名访问 anonymous requests</a> 或 <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" target="_blank" rel="noopener">Service Account Tokens</a> 被启用的情况下</li>
</ul>
</li>
<li><p>节点上必须配置集群（apiserver）的公钥根证书（public root certificate）</p>
<ul>
<li>在提供有效的客户端身份认证的情况下，节点可以安全地访问 APIServer</li>
</ul>
</li>
<li><p>对于需要调用 APIServer 接口的 Pod，应该为其关联 Service Account</p>
<ul>
<li>Kubernetes 将在创建 Pod 时自动为其注入公钥根证书（public root certificate）以及一个有效的 bearer token（放在 HTTP 请求头 Authorization 字段）</li>
<li>所有名称空间中，都默认配置了名为 <code>kubernetes</code> Kubernetes Service，该 Service 对应一个虚拟 IP（默认为 10.96.0.1），发送到该地址的请求将由 kube-proxy 转发到 apiserver 的 HTTPS 端口上</li>
</ul>
</li>
<li><p>得益于这些措施，默认情况下从集群（节点以及节点上运行的 Pod）访问 master 的连接是安全的，因此可以通过不受信的网络或公网连接 Kubernetes 集群</p>
</li>
</ul>
<h4 id="Master-to-Cluster"><a href="#Master-to-Cluster" class="headerlink" title="Master to Cluster"></a>Master to Cluster</h4><p>从 master（apiserver）到 Cluster 存在着两条主要的通信路径：</p>
<ul>
<li>apiserver 访问集群中每个节点上的 kubelet 进程</li>
<li>使用 apiserver 的 proxy 功能，从 apiserver 访问集群中的任意节点、Pod、Service</li>
</ul>
<h5 id="apiserver-to-kubelet"><a href="#apiserver-to-kubelet" class="headerlink" title="apiserver to kubelet"></a>apiserver to kubelet</h5><ul>
<li><p>apiserver 在如下情况下访问 kubelet：</p>
<ul>
<li>抓取 Pod 的日志</li>
<li>通过 <code>kubectl exec -it</code> 指令获得容器的命令行终端</li>
<li>提供 <code>kubectl port-forward</code> 功能</li>
</ul>
</li>
<li><p>这些连接的访问端点是 kubelet 的 HTTPS 端口</p>
<ul>
<li>默认情况下，apiserver 不校验 kubelet 的 HTTPS 证书，连接可能会收到 man-in-the-middle 攻击</li>
<li>因此该连接如果在不受信网络或者公网上运行时，是 <strong>不安全</strong> 的</li>
</ul>
</li>
<li><p>如果要校验 kubelet 的 HTTPS 证书，可以通过 <code>--kubelet-certificate-authority</code> 参数为 apiserver 提供校验 kubelet 证书的根证书</p>
</li>
<li><p>如果不能完成这个配置，又需要通过不受信网络或公网将节点加入集群，则需要使用 <strong>SSH隧道</strong> 连接 apiserver 和 kubelet</p>
<ul>
<li>apiserver 将向集群中的每一个节点建立一个 SSH 隧道（连接到端口 22 的 ssh 服务）并通过隧道传递所有发向 kubelet、node、pod、service 的请求</li>
<li>SSH隧道当前已被不推荐使用（deprecated），Kubernetes 正在设计新的替代通信方式</li>
</ul>
</li>
<li><p>同时 <a href="https://kubernetes.io/docs/admin/kubelet-authentication-authorization/" target="_blank" rel="noopener">Kubelet authentication/authorization</a> 需要激活，以保护 kubelet API</p>
</li>
</ul>
<h5 id="apiserver-to-nodes-pods-services"><a href="#apiserver-to-nodes-pods-services" class="headerlink" title="apiserver to nodes, pods, services"></a>apiserver to nodes, pods, services</h5><ul>
<li>从 apiserver 到 节点/Pod/Service 的连接使用的是 HTTP 连接，没有进行身份认证，也没有进行加密传输</li>
<li>也可以通过增加 <code>https</code> 作为 节点/Pod/Service 请求 URL 的前缀<ul>
<li>但是 HTTPS 证书并不会被校验，也无需客户端身份认证，因此该连接是无法保证一致性的</li>
<li>目前此类连接如果运行在非受信网络或公网上时，是 <strong>不安全</strong> 的</li>
</ul>
</li>
</ul>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul>
<li>控制器不断监控着集群的状态，并对集群做出对应的变更调整</li>
<li>每一个控制器都不断地尝试着将 <strong>当前状态</strong> 调整到 <strong>目标状态</strong></li>
</ul>
<h4 id="控制器模式"><a href="#控制器模式" class="headerlink" title="控制器模式"></a>控制器模式</h4><ul>
<li>在 Kubernetes 中，每个控制器至少追踪一种类型的资源<ul>
<li>这些资源对象中有一个 <code>spec</code> 字段代表了目标状态</li>
<li>资源对象对应的控制器负责不断地将当前状态调整到目标状态</li>
</ul>
</li>
<li>理论上控制器可以自己直接执行调整动作，然而在 Kubernetes 中更普遍的做法是发送消息到 API Server，而不是直接自己执行</li>
</ul>
<h5 id="通过-APIServer-进行控制"><a href="#通过-APIServer-进行控制" class="headerlink" title="通过 APIServer 进行控制"></a>通过 APIServer 进行控制</h5><ul>
<li><p>Kubernetes 自带的控制器都是通过与集群中 API Server 交互来达到调整状态的目的</p>
</li>
<li><p>以 Kubernetes 中自带的一个控制器 Job Controller 为例</p>
<ul>
<li>Job 是一种 Kubernetes API 对象，一个 Job 将运行一个（或多个）Pod，执行一项任务，然后停止</li>
<li>当新的 Job 对象被创建时，Job Controller 将确保集群中有合适数量的节点上的 kubelet 启动了指定个数的 Pod，以完成 Job 的执行任务</li>
<li>Job Controller 自己并不执行任何 Pod 或容器，而是发消息给 API Server，由其他的控制组件配合 API Server，以执行创建或删除 Pod 的实际动作</li>
<li>当新的 Job 对象被创建时，目标状态是指定的任务被执行完成</li>
<li>Job Controller 调整集群的当前状态以达到目标状态：创建 Pod 以执行 Job 中指定的任务</li>
</ul>
</li>
<li><p>控制器同样也会更新其关注的 API 对象</p>
<ul>
<li>例如一旦 Job 的任务执行结束，Job Controller 将更新 Job 的 API 对象，将其标注为 <code>Finished</code></li>
</ul>
</li>
</ul>
<h5 id="直接控制"><a href="#直接控制" class="headerlink" title="直接控制"></a>直接控制</h5><ul>
<li>某些特殊的控制器需要对集群外部的东西做调整</li>
<li>例如想用一个控制器确保集群中有足够的节点，此时控制器需要调用云供应商的接口以创建新的节点或移除旧的节点</li>
<li>这类控制器将从 API Server 中读取关于目标状态的信息，并直接调用外部接口以实现调整目标</li>
</ul>
<h4 id="目标状态-vs-当前状态"><a href="#目标状态-vs-当前状态" class="headerlink" title="目标状态 vs 当前状态"></a>目标状态 vs 当前状态</h4><ul>
<li><p>Kubernetes 使用了 <code>云原生</code>（cloud-native）的视角来看待系统，并且可以持续应对变化</p>
<ul>
<li>集群在运行的过程中，任何时候都有可能发生突发事件，而控制器则自动地修正这些问题</li>
</ul>
</li>
<li><p>这是一种更高级的系统形态，尤其是在运行一个大规模的复杂集群的情况下</p>
</li>
</ul>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><ul>
<li><p>作为一个底层设计原则，Kubernetes 使用了大量的控制器，每个控制器都用来管理集群状态的某一个方面</p>
<ul>
<li>普遍来说，任何一个特定的控制器都使用一种 API 对象作为其目标状态，并使用和管理多种类型的资源，以达到目标状态</li>
</ul>
</li>
<li><p>使用许多个简单的控制器比使用一个全能的控制器要更加有优势</p>
<ul>
<li>控制器可能会出故障，而这也是在设计 Kubernetes 时要考虑到的事情</li>
</ul>
</li>
<li><p>可能存在多种控制器可以创建或更新相同类型的 API 对象</p>
<ul>
<li>为了避免混淆，Kubernetes 控制器在创建新的 API 对象时，会将该对象与对应的控制 API 对象关联，并且只关注与控制对象关联的那些对象</li>
<li>例如 Deployment 和 Job，这两类控制器都创建 Pod<ul>
<li>Job Controller 不会删除 Deployment Controller 创建的 Pod，因为控制器可以通过标签信息区分哪些 Pod 是它创建的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="运行控制器的方式"><a href="#运行控制器的方式" class="headerlink" title="运行控制器的方式"></a>运行控制器的方式</h4><ul>
<li>Kubernetes 在 kube-controller-manager 中运行了大量的内建控制器（例如，Deployment Controller、Job Controller、StatefulSet Controller、DaemonSet Controller 等）<ul>
<li>这些内建控制器提供了 Kubernetes 非常重要的核心功能</li>
<li>Kubernetes 可以运行一个 master 集群，以实现内建控制器的高可用</li>
</ul>
</li>
<li>也可以安装一些运行在 kube-controller-manager 之外的控制器，这些控制器通常是对 Kubernetes 已有功能的一些扩展<ul>
<li>或者在必要的情况下，也可以自己编写自己需要的控制器，将其部署为一组 Pod，或者在 Kubernetes 集群之外部署</li>
<li>如何选择取决于想要用这个控制器做什么</li>
</ul>
</li>
</ul>
<h2 id="操作-Kubernetes"><a href="#操作-Kubernetes" class="headerlink" title="操作 Kubernetes"></a>操作 Kubernetes</h2><h3 id="Kubernetes-对象"><a href="#Kubernetes-对象" class="headerlink" title="Kubernetes 对象"></a>Kubernetes 对象</h3><ul>
<li>Kubernetes 将应用程序数据以 Kubernetes 对象的形式通过 api server 存储在 etcd 中</li>
<li>Kubernetes 对象主要描述了:<ul>
<li>集群中运行了哪些容器化应用程序（以及在哪个节点上运行）</li>
<li>集群中对应用程序可用的资源</li>
<li>应用程序相关的策略定义，例如，重启策略、升级策略、容错策略</li>
<li>其他 Kubernetes 管理应用程序时所需要的信息</li>
</ul>
</li>
</ul>
<h4 id="对象的-spec-和-status"><a href="#对象的-spec-和-status" class="headerlink" title="对象的 spec 和 status"></a>对象的 spec 和 status</h4><ul>
<li>每一个 Kubernetes 对象都包含两个重要字段：<ul>
<li><code>spec</code> 必须由开发者来提供，描述了对该对象所期望的 <strong>目标状态</strong></li>
<li><code>status</code> 只能由 Kubernetes 系统来修改，描述了该对象在 Kubernetes 系统中的 <strong>实际状态</strong></li>
</ul>
</li>
<li>Kubernetes 通过对应的控制器，不断地使实际状态趋向于期望的目标状态</li>
</ul>
<h4 id="描述-Kubernetes-对象"><a href="#描述-Kubernetes-对象" class="headerlink" title="描述 Kubernetes 对象"></a>描述 Kubernetes 对象</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span> <span class="comment"># 运行 2 个容器化应用程序副本</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 Kubernetes 中创建一个对象时，必须提供<ul>
<li>该对象的 <code>spec</code> 字段，通过该字段描述期望的 <strong>目标状态</strong></li>
<li>该对象的一些基本信息，例如名字</li>
</ul>
</li>
<li>在上述的 <code>.yaml</code> 文件中，如下字段是必须填写的<ul>
<li><strong>apiVersion</strong> 用来创建对象时所使用的 Kubernetes API 版本</li>
<li><strong>kind</strong> 被创建对象的类型</li>
<li><strong>metadata</strong> 用于唯一确定该对象的元数据：包括 <code>name</code> 和 <code>namespace</code>，如果 <code>namespace</code> 为空，则默认值为 <code>default</code></li>
<li><strong>spec</strong> 描述对该对象的期望状态</li>
</ul>
</li>
</ul>
<h4 id="管理-Kubernetes-对象"><a href="#管理-Kubernetes-对象" class="headerlink" title="管理 Kubernetes 对象"></a>管理 Kubernetes 对象</h4><table>
<thead>
<tr>
<th>管理方式</th>
<th>操作对象</th>
<th>推荐的环境</th>
</tr>
</thead>
<tbody><tr>
<td>指令性的命令行</td>
<td>Kubernetes 对象</td>
<td>开发环境</td>
</tr>
<tr>
<td>指令性的对象配置</td>
<td>单个 yaml 文件</td>
<td>生产环境</td>
</tr>
<tr>
<td>声明式的对象配置</td>
<td>包含多个 yaml 文件的多个目录</td>
<td>生产环境</td>
</tr>
</tbody></table>
<h5 id="指令性的命令行"><a href="#指令性的命令行" class="headerlink" title="指令性的命令行"></a>指令性的命令行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image nginx</span><br></pre></td></tr></table></figure>

<ul>
<li><p>与编写 <code>.yaml</code> 文件进行配置的方式相比的优势</p>
<ul>
<li>命令简单，易学易记</li>
<li>只需要一个步骤，就可以对集群执行变更</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>使用命令，无法进行变更 review 的管理</li>
<li>不提供日志审计</li>
<li>没有创建新对象的模板</li>
</ul>
</li>
</ul>
<h5 id="指令性的对象配置"><a href="#指令性的对象配置" class="headerlink" title="指令性的对象配置"></a>指令性的对象配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li><p>与指令性命令行相比的优点</p>
<ul>
<li>对象配置文件可以存储在源代码管理系统中，例如 git</li>
<li>对象配置文件可以整合进团队的变更管理流程，并进行审计和复核</li>
<li>对象配置文件可以作为一个模板，直接用来创建新的对象</li>
</ul>
</li>
<li><p>与指令性命令行相比的缺点</p>
<ul>
<li>需要理解对象配置文件的基本格式</li>
<li>需要额外编写 yaml 文件</li>
</ul>
</li>
<li><p>与声明式的对象配置相比的优点</p>
<ul>
<li>指令性的对象配置更简单更易于理解</li>
<li>指令性的对象配置更成熟</li>
</ul>
</li>
<li><p>与声明式的对象配置相比的缺点</p>
<ul>
<li>指令性的对象配置基于文件进行工作，而不是目录</li>
<li>如果直接更新 Kubernetes 中对象，最好也同时修改配置文件，否则在下一次替换时，这些更新将丢失</li>
</ul>
</li>
</ul>
<h5 id="声明式的对象配置"><a href="#声明式的对象配置" class="headerlink" title="声明式的对象配置"></a>声明式的对象配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -R -f configs/</span><br><span class="line">kubectl apply -R -f configs/</span><br></pre></td></tr></table></figure>

<ul>
<li><p>与指令性的对象配置相比，优点有：</p>
<ul>
<li>直接针对 Kubernetes 已有对象的修改将被保留，即使这些信息没有合并到配置文件中<ul>
<li>也许这是一个缺点, 因为对象可能与配置文件描述的不一致，或者需要禁止使用其他手段修改 Kubernetes 中已有的对象</li>
</ul>
</li>
<li>声明式的对象配置可以支持多文件目录的处理，可以自动探测应该对具体每一个对象执行什么操作（创建、更新、删除）</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>声明式的对象配置复杂度更高，Debug 更困难</li>
<li>部分更新对象时，带来复杂的合并操作</li>
</ul>
</li>
</ul>
<h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><ul>
<li>Kubernetes REST API 中，所有的对象都是通过 <code>name</code> 和 <code>UID</code> 唯一性确定</li>
</ul>
<h4 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h4><ul>
<li><p>可以通过 <code>namespace</code> + <code>name</code> 唯一性地确定一个 RESTFUL 对象</p>
<ul>
<li>例如 <code>/api/v1/namespaces/{namespace}/pods/{name}</code></li>
</ul>
</li>
<li><p>同一个名称空间下，同一个类型的对象，可以通过 <code>name</code> 唯一性确定</p>
<ul>
<li>如果删除该对象之后，可以再重新创建一个同名对象</li>
</ul>
</li>
</ul>
<h5 id="DNS-Subdomain-Names"><a href="#DNS-Subdomain-Names" class="headerlink" title="DNS Subdomain Names"></a>DNS Subdomain Names</h5><ul>
<li>绝大部分资源类型的名称必须符合 DNS subdomain 命名规则 <a href="https://tools.ietf.org/html/rfc1123" target="_blank" rel="noopener">RFC 1123</a><ul>
<li>最长不超过 253个字符</li>
<li>必须由小写字母、数字、减号 <code>-</code>、小数点 <code>.</code> 组成</li>
<li>由字母开始</li>
<li>由字母结束</li>
</ul>
</li>
</ul>
<h5 id="DNS-Label-Names"><a href="#DNS-Label-Names" class="headerlink" title="DNS Label Names"></a>DNS Label Names</h5><ul>
<li>部分类型的资源要求其名称符合 DNS Label 的命名规则 <a href="https://tools.ietf.org/html/rfc1123" target="_blank" rel="noopener">RFC 1123</a><ul>
<li>最长不超过 63 个字符</li>
<li>必须由小写字母、数字、减号 <code>-</code>、小数点 <code>.</code> 组成</li>
<li>由字母开始</li>
<li>由字母结束</li>
</ul>
</li>
</ul>
<h5 id="Path-Segment-Names"><a href="#Path-Segment-Names" class="headerlink" title="Path Segment Names"></a>Path Segment Names</h5><ul>
<li>部分类型的资源要求其名称可以被编码到路径中。换句话说，名称中不能包含 <code>.</code>、<code>..</code>、<code>/</code>、<code>%</code></li>
</ul>
<h4 id="UIDs"><a href="#UIDs" class="headerlink" title="UIDs"></a>UIDs</h4><ul>
<li><p>UID 是由 Kubernetes 系统生成的，唯一标识某个 Kubernetes 对象的字符串</p>
</li>
<li><p>Kubernetes 集群中，每创建一个对象，都有一个唯一的 UID, 用于区分多次创建的同名对象</p>
<ul>
<li>如前所述，按照名字删除对象后，重新再创建同名对象时，两次创建的对象 name 相同，但是 UID 不同</li>
</ul>
</li>
<li><p>Kubernetes 中的 UID 是全局唯一的标识符（UUIDs，符合规范 ISO/IEC 9834-8 以及 ITU-T X.667）</p>
</li>
</ul>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><ul>
<li><p>Kubernetes 通过名称空间（namespace）在同一个物理集群上支持多个虚拟集群</p>
</li>
<li><p>名称空间内部的同类型对象不能重名，但是跨名称空间可以有同名同类型对象</p>
</li>
<li><p>名称空间不可以嵌套，任何一个 Kubernetes 对象只能在一个名称空间中</p>
</li>
<li><p>名称空间可以用来在不同的团队（用户）之间划分集群的资源</p>
</li>
<li><p>Kubernetes 安装成功后，默认有初始化了三个名称空间</p>
<ul>
<li><strong>default</strong> 默认名称空间，如果 Kubernetes 对象中不定义 <code>metadata.namespace</code> 字段，该对象将放在此名称空间下</li>
<li><strong>kube-system</strong> Kubernetes 系统创建的对象放在此名称空间下</li>
<li><strong>kube-public</strong> 此名称空间在安装集群时自动创建，并且所有用户都是可以读取的（即使是那些未登录的用户）<ul>
<li>主要是为集群预留的，例如某些情况下，某些 Kubernetes 对象应该被所有集群用户看到</li>
</ul>
</li>
</ul>
</li>
<li><p>某些低层级的对象是不在任何名称空间中的，例如 <a href="https://kuboard.cn/learning/k8s-bg/architecture/nodes.html" target="_blank" rel="noopener">nodes</a>、<a href="https://kuboard.cn/learning/k8s-intermediate/persistent/pv.html" target="_blank" rel="noopener">persistentVolumes</a>、<a href="https://kuboard.cn/learning/k8s-intermediate/persistent/storage-class.html" target="_blank" rel="noopener">storageClass</a> 等</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看在名称空间里的对象</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不在名称空间里的对象</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="名称空间与-DNS"><a href="#名称空间与-DNS" class="headerlink" title="名称空间与 DNS"></a>名称空间与 DNS</h4><ul>
<li>创建一个 Service 时，Kubernetes 为其创建一个对应的 <a href="https://kuboard.cn/learning/k8s-intermediate/service/dns.html" target="_blank" rel="noopener">DNS 条目</a></li>
<li>该 DNS 记录的格式为 <code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code><ul>
<li>如果在容器中只使用 <code>&lt;service-name&gt;</code>，其 DNS 将解析到同名称空间下的 Service</li>
<li>这个特点在多环境的情况下非常有用，例如将开发环境、测试环境、生产环境部署在不同的名称空间下，应用程序只需要使用 <code>&lt;service-name&gt;</code> 即可进行服务发现，无需为不同的环境修改配置</li>
<li>如果想跨名称空间访问服务，则必须使用完整的域名（fully qualified domain name，FQDN）</li>
</ul>
</li>
</ul>
<h4 id="使用名称空间共享集群"><a href="#使用名称空间共享集群" class="headerlink" title="使用名称空间共享集群"></a>使用名称空间共享集群</h4><h5 id="查看名称空间"><a href="#查看名称空间" class="headerlink" title="查看名称空间"></a>查看名称空间</h5><ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespaces</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME          STATUS    AGE</span><br><span class="line">default       Active    11d</span><br><span class="line">kube-system   Active    11d</span><br><span class="line">kube-public   Active    11d</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="查看概要信息"><a href="#查看概要信息" class="headerlink" title="查看概要信息"></a>查看概要信息</h5><ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe namespaces &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Name:           default</span><br><span class="line">Labels:         &lt;none&gt;</span><br><span class="line">Annotations:    &lt;none&gt;</span><br><span class="line">Status:         Active</span><br><span class="line"></span><br><span class="line">No resource quota.</span><br><span class="line"></span><br><span class="line">Resource Limits</span><br><span class="line"> Type       Resource    Min Max Default</span><br><span class="line"> ----               --------    --- --- ---</span><br><span class="line"> Container          cpu         -   -   100m</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Resource quota</strong> 汇总了名称空间中使用的资源总量，并指定了集群管理员定义该名称空间最多可以使用的资源量</p>
</li>
<li><p><strong>Limit range</strong> 定义了名称空间中某种具体的资源类型的最大、最小值</p>
</li>
<li><p>名称空间可能有两种状态（phase）</p>
<ul>
<li><strong>Active</strong> 名称空间正在使用中</li>
<li><strong>Termining</strong> 名称空间正在被删除，不能再向其中创建新的对象</li>
</ul>
</li>
</ul>
<h5 id="创建名称空间"><a href="#创建名称空间" class="headerlink" title="创建名称空间"></a>创建名称空间</h5><ul>
<li><p>直接使用命令创建名称空间</p>
<ul>
<li><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace &lt;名称空间的名字&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过 yaml 文件</p>
<ul>
<li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">&lt;名称空间的名字&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>名称空间的名字必须与 DNS 兼容</p>
<ul>
<li>不能带小数点 <code>.</code></li>
<li>不能带下划线 <code>_</code></li>
<li>使用数字、小写字母和减号 <code>-</code> 组成的字符串</li>
</ul>
</li>
<li><p>名称空间可以定义一个可选项字段 <code>finalizers</code>，在名称空间被删除时，用来清理相关的资源</p>
<ul>
<li>如果定义了一个不存在的 <code>finalizer</code>，仍然可以成功创建名称空间，但是您删除该名称空间时，将卡在 <code>Terminating</code> 状态</li>
</ul>
</li>
</ul>
<h5 id="删除名称空间"><a href="#删除名称空间" class="headerlink" title="删除名称空间"></a>删除名称空间</h5><ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete namespaces &lt;名称空间的名字&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该操作将删除名称空间中的所有内容</p>
</li>
<li><p>此删除操作是异步的，可能会观察到名称空间停留会在 <code>Terminating</code> 状态停留一段时间</p>
</li>
</ul>
<h3 id="标签和选择器"><a href="#标签和选择器" class="headerlink" title="标签和选择器"></a>标签和选择器</h3><ul>
<li>标签（Label）是附加在 Kubernetes 对象上的一组键值对，其意图是按照对用户有意义的方式来标识Kubernetes对象，同时又不对Kubernetes 的核心逻辑产生影响</li>
</ul>
<h4 id="句法和字符集"><a href="#句法和字符集" class="headerlink" title="句法和字符集"></a>句法和字符集</h4><ul>
<li><p>标签的 key 可以有两个部分：可选的前缀和标签名，通过 <code>/</code> 分隔</p>
<ul>
<li>标签名：<ul>
<li>标签名部分是必须的</li>
<li>不能多于 63 个字符</li>
<li>必须由字母、数字开始和结尾</li>
<li>可以包含字母、数字、减号<code>-</code>、下划线<code>_</code>、小数点<code>.</code></li>
</ul>
</li>
<li>标签前缀：<ul>
<li>标签前缀部分是可选的</li>
<li>如果指定，必须是一个 DNS 的子域名，例如：k8s.eip.work</li>
<li>不能多于 253 个字符</li>
<li>使用 <code>/</code> 和标签名分隔</li>
</ul>
</li>
<li>如果省略标签前缀，则标签的 key 将被认为是专属于用户的</li>
<li>Kubernetes 的系统组件（例如，kube-scheduler、kube-controller-manager、kube-apiserver、kubectl 或其他第三方组件）向用户的 Kubernetes 对象添加标签时，必须指定一个前缀</li>
<li><code>kubernetes.io/</code> 和 <code>k8s.io/</code> 这两个前缀是 Kubernetes 核心组件预留的</li>
</ul>
</li>
<li><p>标签的 value 必须：</p>
<ul>
<li>不能多于 63 个字符</li>
<li>可以为空字符串</li>
<li>如果不为空，则<ul>
<li>必须由字母、数字开始和结尾</li>
<li>可以包含字母、数字、减号<code>-</code>、下划线<code>_</code>、小数点<code>.</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><ul>
<li>通过使用标签选择器（label selector），用户/客户端可以选择一组对象</li>
<li>Kubernetes api server 支持两种形式的标签选择器，<code>equality-based 基于等式的</code> 和 <code>set-based 基于集合的</code></li>
<li>标签选择器可以包含多个条件，并使用逗号分隔，此时只有满足所有条件的 Kubernetes 对象才会被选中</li>
</ul>
<h5 id="基于等式的选择方式"><a href="#基于等式的选择方式" class="headerlink" title="基于等式的选择方式"></a>基于等式的选择方式</h5><ul>
<li><p>Equality-based 或者 Inequality-based 选择器可以使用标签的名和值来执行过滤选择</p>
</li>
<li><p>只有匹配所有条件的对象才被选中（被选中的对象可以包含未指定的标签）</p>
</li>
<li><p>可以使用三种操作符 <code>=</code>、<code>==</code>、<code>!=</code></p>
<ul>
<li>前两个操作符含义是一样的，都代表相等，后一个操作符代表不相等</li>
</ul>
</li>
<li><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择了标签名为 `environment` 且 标签值为 `production` 的 Kubernetes 对象</span></span><br><span class="line">environment = production</span><br><span class="line"><span class="comment"># 选择了标签名为 `tier` 且标签值不等于 `frontend` 的对象，以及不包含标签 `tier` 的对象</span></span><br><span class="line">tier != frontend</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以使用逗号分隔的两个等式 <code>environment=production,tier!=frontend</code>，此时将选中所有 <code>environment</code> 为 <code>production</code> 且 <code>tier</code> 不为 <code>frontend</code> 的对象</li>
</ul>
</li>
<li><p>以 <a href="https://kuboard.cn/learning/k8s-intermediate/config/assign-pod-node.html#节点选择器-nodeselector" target="_blank" rel="noopener">Pod 的节点选择器</a> 为例，下面的 Pod 可以被调度到包含标签 <code>accelerator=nvidia-tesla-p100</code> 的节点上：</p>
<ul>
<li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cuda-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">cuda-test</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">"k8s.gcr.io/cuda-vector-add:v0.1"</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line">          <span class="string">nvidia.com/gpu:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line"><span class="attr">    accelerator:</span> <span class="string">nvidia-tesla-p100</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="基于集合的选择方式"><a href="#基于集合的选择方式" class="headerlink" title="基于集合的选择方式"></a>基于集合的选择方式</h5><ul>
<li><p>Set-based 标签选择器可以根据标签名的一组值进行筛选</p>
</li>
<li><p>支持的操作符有：<code>in</code>、<code>notin</code>、<code>exists</code> </p>
<ul>
<li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择所有的包含 `environment` 标签且值为 `production` 或 `qa` 的对象</span></span><br><span class="line">environment in (production, qa)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择所有的 `tier` 标签不为 `frontend` 和 `backend`的对象，或不含 `tier` 标签的对象</span></span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择所有包含 `partition` 标签的对象</span></span><br><span class="line">partition</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择所有不包含 `partition` 标签的对象</span></span><br><span class="line">!partition</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可以组合多个选择器，用 <code>,</code> 分隔，<code>,</code> 相当于 <code>AND</code> 操作符</p>
<ul>
<li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择包含 `partition` 标签（不检查标签值）且 `environment` 不是 `qa` 的对象</span></span><br><span class="line">partition,environment notin (qa)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>基于集合的选择方式是一个更宽泛的基于等式的选择方式, 也可以和基于等式的选择方式混合使用，例如： <code>partition in (customerA, customerB),environment!=qa</code></p>
</li>
</ul>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h5><ul>
<li><p>LIST 和 WATCH 操作时，可指定标签选择器作为查询条件，以筛选指定的对象集合</p>
</li>
<li><p>两种选择方式都可以使用，但是要符合 URL 编码</p>
<ul>
<li>基于等式的选择方式： <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li>
<li>基于集合的选择方式： <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li>
</ul>
</li>
<li><p>两种选择方式都可以在 kubectl 的 list 和 watch 命令中使用</p>
<ul>
<li>基于等式的选择方式： <code>kubectl get pods -l environment=production,tier=frontend</code></li>
<li>基于集合的选择方式： <code>kubectl get pods -l &#39;environment in (production),tier in (frontend)&#39;</code></li>
</ul>
</li>
</ul>
<h5 id="Kubernetes-对象引用"><a href="#Kubernetes-对象引用" class="headerlink" title="Kubernetes 对象引用"></a>Kubernetes 对象引用</h5><ul>
<li>某些 Kubernetes 对象中（例如，Service和Deployment），使用标签选择器指定一组其他类型的 Kubernetes 对象（例如，Pod）</li>
</ul>
<h6 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h6><ul>
<li><p>Service 中通过 <code>spec.selector</code> 字段来选择一组 Pod，并将服务请求转发到选中的 Pod 上</p>
</li>
<li><p>在 yaml 或 json 文件中，标签选择器用一个 map 来定义，且支持基于等式的选择方式</p>
<ul>
<li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">  component:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="有些对象支持基于集合的选择方式"><a href="#有些对象支持基于集合的选择方式" class="headerlink" title="有些对象支持基于集合的选择方式"></a>有些对象支持基于集合的选择方式</h6><ul>
<li><p><code>Job</code>、<code>Deployment</code>、<code>ReplicaSet</code> 和 <code>DaemonSet</code> 同时支持基于等式的选择方式和基于集合的选择方式</p>
<ul>
<li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">  matchLabels:</span></span><br><span class="line"><span class="attr">    component:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  matchExpressions:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;key:</span> <span class="string">tier,</span> <span class="attr">operator:</span> <span class="string">In,</span> <span class="attr">values:</span> <span class="string">[cache]&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;key:</span> <span class="string">environment,</span> <span class="attr">operator:</span> <span class="string">NotIn,</span> <span class="attr">values:</span> <span class="string">[dev]&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>matchLabels</code> 是一个 {key,value} 组成的 map, map 中的一个条目相当于 <code>matchExpressions</code> 中的一个元素</p>
<ul>
<li><code>key</code> 为 map 的 key，<code>operator</code> 为 <code>In</code>， <code>values</code> 数组则只包含 <code>value</code> 一个元素</li>
<li><code>matchExpression</code> 等价于基于集合的选择方式，支持的 <code>operator</code> 有 <code>In</code>、<code>NotIn</code>、<code>Exists</code> 和 <code>DoesNotExist</code></li>
<li>当 <code>operator</code> 为 <code>In</code> 或 <code>NotIn</code> 时，<code>values</code> 数组不能为空</li>
<li>所有的选择条件都以 AND 的形式合并计算，即所有的条件都满足才可以算是匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li><p>注解（annotation）可以用来向 Kubernetes 对象的 <code>metadata.annotations</code> 字段添加任意的信息</p>
</li>
<li><p>Kubernetes 的客户端或者自动化工具可以存取这些信息以实现其自定义的逻辑</p>
</li>
<li><p>Kubernetes 对象的 <code>metadata</code> 字段可以添加自定义的标签（label）或者注解（annotation）</p>
<ul>
<li><p>注解不是用来标记对象或者选择对象的</p>
</li>
<li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">deployment.kubernetes.io/revision:</span> <span class="number">7</span>  <span class="comment"># 由 Deployment 控制器添加，用于记录当前发布的修改次数</span></span><br><span class="line">    <span class="string">k8s.eip.work/displayName:</span> <span class="string">busybox</span>   <span class="comment"># Kuboard 添加，Deployment 显示在 Kuboard 界面上的名字</span></span><br><span class="line">    <span class="string">k8s.eip.work/ingress:</span> <span class="literal">false</span>     <span class="comment"># Kuboard 添加，根据此参数显示 Deployment 是否配置了 Ingress</span></span><br><span class="line">    <span class="string">k8s.eip.work/service:</span> <span class="string">none</span>      <span class="comment"># Kuboard 添加，根据此参数显示 Deployment 是否配置了 Service</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注解的 key 与标签的 key 的规则相同, value 的无限制</p>
</li>
</ul>
<h3 id="字段选择器"><a href="#字段选择器" class="headerlink" title="字段选择器"></a>字段选择器</h3><ul>
<li><p>字段选择器（Field Selector）可以用来基于的一个或多个字段的取值来选取一组 Kubernetes 对象</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择所有字段 `status.phase` 的取值为 `Running` 的 Pod</span></span><br><span class="line">kubectl get pods --field-selector status.phase=Running</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不同的 Kubernetes 对象类型，可以用来查询的字段不一样</p>
</li>
<li><p>所有的对象类型都支持的两个字段是 <code>metadata.name</code> 和 <code>metadata.namespace</code></p>
</li>
<li><p>在字段选择器中使用不支持的字段将报错</p>
</li>
<li><p>字段选择器中可以使用的操作符有 <code>=</code>、<code>==</code>、<code>!=</code> （<code>=</code> 和 <code>==</code> 含义相同）</p>
</li>
<li><p>可以指定多个字段选择器，用逗号 <code>,</code> 分隔</p>
</li>
<li><p>字段选择器可以跨资源类型使用</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有的不在 `default` 名称空间的 StatefulSet 和 Service</span></span><br><span class="line">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><ul>
<li><p>Kubernetes 中，默认的镜像抓取策略是 <code>IfNotPresent</code></p>
<ul>
<li>使用此策略，kubelet 在发现本机有镜像的情况下，不会向镜像仓库抓取镜像</li>
</ul>
</li>
<li><p>imagePullPolicy 字段和 image tag 的可能取值将影响到 kubelet 如何抓取镜像：</p>
<ul>
<li><code>imagePullPolicy: IfNotPresent</code> 仅在节点上没有该镜像时，从镜像仓库抓取</li>
<li><code>imagePullPolicy: Always</code> 每次启动 Pod 时，从镜像仓库抓取</li>
<li><code>imagePullPolicy</code> 未填写，镜像 tag 为 <code>:latest</code> 或者未填写，则同 <code>Always</code> 每次启动 Pod 时，从镜像仓库抓取</li>
<li><code>imagePullPolicy</code> 未填写，镜像 tag 已填写但不是 <code>:latest</code>，则同 <code>IfNotPresent</code> 仅在节点上没有该镜像时，从镜像仓库抓取</li>
<li><code>imagePullPolicy: Never</code>，Kubernetes 假设本地存在该镜像，并且不会尝试从镜像仓库抓取镜像</li>
</ul>
</li>
<li><p>在生产环境部署时应该避免使用 <code>:latest</code> tag，如果这样做将无法追踪当前正在使用的镜像版本，也无法正确地执行回滚动作</p>
</li>
<li><p>如果要 100% 确保所有的容器都使用了同样的镜像版本，可以尝试使用镜像的 <a href="https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier" target="_blank" rel="noopener">digest</a>，例如 <code>sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code></p>
<ul>
<li>Digest 唯一地标识了容器镜像的版本，并且永远不会改变</li>
</ul>
</li>
</ul>
<h3 id="容器的环境变量"><a href="#容器的环境变量" class="headerlink" title="容器的环境变量"></a>容器的环境变量</h3><ul>
<li><p>在容器创建时，集群中所有的 Service 的连接信息将以环境变量的形式注入到容器中</p>
<ul>
<li><p>例如，已创建了一个名为 <code>Foo</code> 的 Service，此时再创建任何容器时，该容器将包含如下环境变量</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FOO_SERVICE_HOST=&lt;Service的ClusterIP&gt;</span><br><span class="line">FOO_SERVICE_PORT=&lt;Service的端口&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="Runtime-Class"><a href="#Runtime-Class" class="headerlink" title="Runtime Class"></a>Runtime Class</h3><ul>
<li>通过 RuntimeClass，使不同的 Pod 使用不同的容器引擎，以在性能和安全之间取得平衡</li>
<li>RuntimeClass 的 feature gate 在 apiserver 和 kubelet 上默认都是激活状态</li>
</ul>
<h3 id="容器的生命周期-容器钩子"><a href="#容器的生命周期-容器钩子" class="headerlink" title="容器的生命周期 - 容器钩子"></a>容器的生命周期 - 容器钩子</h3><ul>
<li><p>Kubernetes中为容器提供了两个 hook（钩子函数）</p>
<ul>
<li><p><code>PostStart</code>  </p>
<ul>
<li>此钩子函数在容器创建后将立刻执行</li>
<li>并不能保证该钩子函数在容器的 <code>ENTRYPOINT</code> 之前执行</li>
<li>该钩子函数没有输入参数</li>
</ul>
</li>
<li><p><code>PreStop</code>  </p>
<ul>
<li><p>此钩子函数在容器被 terminate（终止）之前执行，例如：</p>
<ul>
<li>通过接口调用删除容器所在 Pod</li>
<li>某些管理事件的发生：健康检查失败、资源紧缺等</li>
</ul>
</li>
<li><p>如果容器已经被关闭或者进入了 <code>completed</code> 状态，preStop 钩子函数的调用将失败</p>
</li>
<li><p>该函数的执行是同步的，即 Kubernetes 将在该函数完成执行之后才删除容器</p>
</li>
<li><p>该钩子函数没有输入参数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="hook-handler-的实现"><a href="#hook-handler-的实现" class="headerlink" title="hook handler 的实现"></a>hook handler 的实现</h4><ul>
<li>Kubernetes 中，容器可以实现两种类型的 hook handler<ul>
<li><strong>Exec</strong> - 在容器的名称空进和 cgroups 中执行一个指定的命令，例如 <code>pre-stop.sh</code><ul>
<li>该命令所消耗的 CPU、内存等资源，将计入容器可以使用的资源限制</li>
</ul>
</li>
<li><strong>HTTP</strong> - 向容器的指定端口发送一个 HTTP 请求</li>
</ul>
</li>
</ul>
<h4 id="hook-handler-的执行"><a href="#hook-handler-的执行" class="headerlink" title="hook handler 的执行"></a>hook handler 的执行</h4><ul>
<li>对于 Pod 而言，hook handler 的调用是同步的<ul>
<li>如果是 <code>PostStart</code> hook，容器的 <code>ENTRYPOINT</code> 和 hook 是同时出发的，然而如果 hook 执行的时间过长或者挂起了，容器将不能进入到 <code>Running</code> 状态</li>
<li><code>PreStop</code> hook 的行为与此相似<ul>
<li>如果 hook 在执行过程中挂起了，Pod phase 将停留在 <code>Terminating</code> 的状态，并且在 <code>terminationGracePeriodSeconds</code> 超时之后，Pod 被删除</li>
</ul>
</li>
<li>如果 <code>PostStart</code> 或者 <code>PreStop</code> hook 执行失败，则 Kubernetes 将 kill（杀掉）该容器</li>
</ul>
</li>
<li>用户应该使其 hook handler 越轻量级越好</li>
</ul>
<h4 id="hook-触发的保证"><a href="#hook-触发的保证" class="headerlink" title="hook 触发的保证"></a>hook 触发的保证</h4><ul>
<li>hook 将至少被触发一次，即当指定事件 <code>PostStart</code> 或 <code>PreStop</code> 发生时，hook 有可能被多次触发</li>
<li>例如 kueblet 在触发 hook 的过程中重启了，该 hook 将在 kubelet 重启后被再次触发</li>
<li>hook handler 的实现需要保证即使多次触发，执行也不会出错</li>
</ul>
<h4 id="调试-hook-handler"><a href="#调试-hook-handler" class="headerlink" title="调试 hook handler"></a>调试 hook handler</h4><ul>
<li>hook handler 的日志并没有在 Pod 的 events 中发布</li>
<li>如果 handler 因为某些原因失败了，kubernetes 将广播一个事件 <code>PostStart</code> hook 发送 <code>FailedPreStopHook</code> 事件</li>
</ul>
<h4 id="定义-postStart-和-preStop-处理程序"><a href="#定义-postStart-和-preStop-处理程序" class="headerlink" title="定义 postStart 和 preStop 处理程序"></a>定义 postStart 和 preStop 处理程序</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      preStop:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span> <span class="string">["/bin/sh","-c","nginx</span> <span class="bullet">-s</span> <span class="string">quit;</span> <span class="string">while</span> <span class="string">killall</span> <span class="bullet">-0</span> <span class="string">nginx;</span> <span class="string">do</span> <span class="string">sleep</span> <span class="number">1</span><span class="string">;</span> <span class="string">done"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>postStart 命令向 <code>usr/share/message</code> 文件写入了一行文字</li>
<li>preStop 命令优雅地关闭了 nginx<ul>
<li>如果容器碰到问题被 Kubernetes 关闭，这个操作是非常有帮助的，可以使得程序在关闭前执行必要的清理任务</li>
</ul>
</li>
</ul>
<h2 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h2><h3 id="Pod-容器组"><a href="#Pod-容器组" class="headerlink" title="Pod (容器组)"></a>Pod (容器组)</h3><ul>
<li><p>Kubernetes 中最小的可部署单元</p>
</li>
<li><p>一个 Pod 包含了一个应用程序容器（某些情况下是多个容器）</p>
<ul>
<li>所有容器都运行在同一个节点</li>
</ul>
</li>
<li><p>每一个 Pod 被分配一个独立的 IP 地址</p>
<ul>
<li>同一个 Pod 中的所有容器 IP 地址都相同</li>
<li>同一个 Pod 中的不同容器不能使用相同的端口，否则会导致端口冲突</li>
<li>同一个 Pod 中的不同容器可以通过 <code>localhost:port</code> 进行通信</li>
<li>同一个 Pod 中的不同容器可以通过使用常规的进程间通信手段，例如 SystemV semaphores 或者 POSIX 共享内存</li>
</ul>
</li>
<li><p>Pod 中可以定义一组共享的数据卷</p>
<ul>
<li>Pod 中所有的容器都可以访问这些共享数据卷，以便共享数据</li>
<li>Pod 中数据卷的数据也可以存储持久化的数据，使得容器在重启后仍然可以访问到之前存入到数据卷中的数据</li>
</ul>
</li>
<li><p>在 Pod 中指定容器端口只是展示作用</p>
<ul>
<li>可以通过对端口命名更方便的使用</li>
</ul>
</li>
<li><p>使用 <code>kubectl port-forward</code> 将本地网络端口转发到 Pod 端口</p>
<ul>
<li><code>kubectl port-forward nginx 8888:80</code> </li>
</ul>
</li>
</ul>
<h4 id="Pod-和-Controller"><a href="#Pod-和-Controller" class="headerlink" title="Pod 和 Controller"></a>Pod 和 Controller</h4><ul>
<li>应该始终使用 Controller (控制器) 来创建 Pod，而不是直接创建 Pod<ul>
<li>Pod 本身并不能自愈（self-healing）</li>
<li>Pod 一直保留在被调度的节点上，直到以下情况发生<ul>
<li>Pod 中的容器全部结束运行</li>
<li>Pod 被删除</li>
<li>由于节点资源不够，Pod 被驱逐</li>
<li>节点出现故障（例如死机）</li>
</ul>
</li>
</ul>
</li>
<li>控制器可以提供如下特性：<ul>
<li>水平扩展（运行 Pod 的多个副本）</li>
<li>rollout（版本更新）</li>
<li>self-healing（故障恢复）</li>
</ul>
</li>
<li>在 Kubernetes 中，广泛使用的控制器有：<ul>
<li>Deployment</li>
<li>StatefulSet</li>
<li>DaemonSet</li>
</ul>
</li>
<li>控制器通过其中配置的 Pod Template 信息来创建 Pod</li>
</ul>
<h5 id="Pod-Template"><a href="#Pod-Template" class="headerlink" title="Pod Template"></a>Pod Template</h5><ul>
<li>Pod Template 是关于 Pod 的定义，但是被包含在其他的 Kubernetes 对象中（例如 Deployment、StatefulSet、DaemonSet 等控制器）</li>
<li>控制器通过 Pod Template 信息来创建 Pod</li>
<li>Pod 由控制器依据 Pod Template 创建以后，此时再修改 Pod Template 的内容，已经创建的 Pod 不会被修改</li>
</ul>
<h4 id="Termination-of-Pods"><a href="#Termination-of-Pods" class="headerlink" title="Termination of Pods"></a>Termination of Pods</h4><ul>
<li><p>Pod 代表了运行在集群节点上的进程，而进程的终止有两种方式：</p>
<ul>
<li>gracefully terminate （优雅地终止）</li>
<li>直接 kill，此时进程没有机会执行清理动作</li>
</ul>
</li>
<li><p>Kubernetes 收到用户删除 Pod 的指令后：</p>
<ul>
<li><p>记录强制终止前的等待时长（grace period）</p>
</li>
<li><p>向 Pod 中所有容器的主进程发送 TERM 信号</p>
</li>
<li><p>一旦等待超时，向超时的容器主进程发送 KILL 信号</p>
</li>
<li><p>删除 Pod 在 API Server 中的记录</p>
</li>
</ul>
</li>
<li><p>每个容器并不是同一时间接受到 TERM 信号，如果容器的关闭顺序很重要，可能需要为每个容器都定义一个 preStop hook</p>
</li>
<li><p>默认情况下，删除 Pod 的 grace period（等待时长）是 30 秒</p>
<ul>
<li>可以通过 kubectl delete 命令的选项 <code>--grace-period=&lt;seconds&gt;</code> 自己指定 grace period（等待时长）</li>
<li>如果要强制删除 Pod，必须为 kubectl delete 命令同时指定两个选项 <code>--grace-period=0</code> 和 <code>--force</code></li>
</ul>
</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="Pod-phase"><a href="#Pod-phase" class="headerlink" title="Pod phase"></a>Pod phase</h5><ul>
<li>Pod phase 代表 Pod 所处生命周期的阶段, 并不是用来代表其容器的状态，也不是一个严格的状态机</li>
</ul>
<table>
<thead>
<tr>
<th>Phase</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Pending</td>
<td>Kubernetes 已经创建并确认该 Pod, 此时可能有两种情况：<br>1. Pod 还未完成调度（例如没有合适的节点）<br>2. 正在从 docker registry 下载镜像</td>
</tr>
<tr>
<td>Running</td>
<td>该 Pod 已经被绑定到一个节点，并且该 Pod 所有的容器都已经成功创建<br>其中至少有一个容器正在运行，或者正在启动 / 重启</td>
</tr>
<tr>
<td>Succeeded</td>
<td>Pod 中的所有容器都已经成功终止，并且不会再被重启</td>
</tr>
<tr>
<td>Failed</td>
<td>Pod 中的所有容器都已经终止，至少一个容器终止于失败状态：容器的进程退出码不是 0，或者被系统 kill</td>
</tr>
<tr>
<td>Unknown</td>
<td>因为某些未知原因，不能确定 Pod 的状态，通常的原因是 master 与 Pod 所在节点之间的通信故障</td>
</tr>
</tbody></table>
<ul>
<li>通常如果没有人或者控制器删除 Pod，Pod 不会自己消失<ul>
<li>只有一种例外，那就是 Pod 处于 Scucceeded 或 Failed 的 phase，并超过了垃圾回收的时长（在 kubernetes master 中通过 terminated-pod-gc-threshold 参数指定），kubelet 自动将其删除</li>
</ul>
</li>
</ul>
<h5 id="Pod-conditions"><a href="#Pod-conditions" class="headerlink" title="Pod conditions"></a>Pod conditions</h5><ul>
<li>每一个 Pod 都有一个数组描述其是否达到某些指定的条件</li>
<li>该数组的每一行可能有六个字段</li>
</ul>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>type 是最重要的字段，可能的取值有：<br><strong>PodScheduled：</strong> Pod 已被调度到一个节点<br><strong>Ready：</strong> Pod 已经可以接受服务请求，应该被添加到所匹配 Service 的负载均衡的资源池<br><strong>Initialized：</strong>Pod 中所有初始化容器已成功执行<br><strong>Unschedulable：</strong>不能调度该 Pod（缺少资源或者其他限制）<br><strong>ContainersReady：</strong>Pod 中所有容器都已就绪</td>
</tr>
<tr>
<td>status</td>
<td>可能能的取值有：True, False, Unknown</td>
</tr>
<tr>
<td>reason</td>
<td>Condition 发生变化的原因，使用一个符合驼峰规则的英文单词描述</td>
</tr>
<tr>
<td>message</td>
<td>Condition 发生变化的原因的详细描述，human-readable</td>
</tr>
<tr>
<td>lastTransitionTime</td>
<td>Condition 发生变化的时间戳</td>
</tr>
<tr>
<td>lastProbeTime</td>
<td>上一次针对 Pod 做健康检查/就绪检查的时间戳</td>
</tr>
</tbody></table>
<h5 id="健康检查-Probe-探针"><a href="#健康检查-Probe-探针" class="headerlink" title="健康检查 - Probe (探针)"></a>健康检查 - Probe (探针)</h5><ul>
<li><p>Probe 是指 kubelet 周期性地检查容器的状况, 有三种类型的 Probe:</p>
<ul>
<li><strong>ExecAction</strong><ul>
<li>在容器内执行一个指定的命令</li>
<li>如果该命令的退出状态码为 0，则成功</li>
</ul>
</li>
<li><strong>TCPSocketAction</strong><ul>
<li>探测容器的指定 TCP 端口</li>
<li>如果该端口处于 open 状态，则成功</li>
</ul>
</li>
<li><strong>HTTPGetAction</strong><ul>
<li>探测容器指定端口/路径上的 HTTP Get 请求</li>
<li>如果 HTTP 响应状态码在 200 到 400（不包含400）之间，则成功</li>
</ul>
</li>
</ul>
</li>
<li><p>Probe 有三种可能的结果：</p>
<ul>
<li><strong>Success：</strong> 容器通过检测</li>
<li><strong>Failure：</strong> 容器未通过检测</li>
<li><strong>Unknown：</strong> 检测执行失败，此时 kubelet 不做任何处理</li>
</ul>
</li>
<li><p>Kubelet 可以在两种情况下对运行中的容器执行 Probe:</p>
<ul>
<li><strong>就绪检查 readinessProbe</strong><ul>
<li>确定容器是否已经就绪并接收服务请求</li>
<li>如果就绪检查失败，kubernetes 将该 Pod 的 IP 地址从所有匹配的 Service 的资源池中移除掉</li>
</ul>
</li>
<li><strong>健康检查 livenessProbe</strong><ul>
<li>确定容器是否正在运行</li>
<li>如果健康检查失败，kubelete 将结束该容器，并根据 restart policy（重启策略）确定是否重启该容器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h6><ul>
<li>如果容器中的进程在碰到问题时可以自己 crash，则并不需要执行健康检查<ul>
<li>kubelet 可以自动的根据 Pod 的 restart policy（重启策略）执行对应的动作</li>
</ul>
</li>
<li>如果希望在容器的进程无响应后，将容器 kill 掉并重启，则指定一个健康检查 liveness probe，并同时指定 restart policy（重启策略）为 Always 或者 OnFailure</li>
<li>如果想在探测 Pod 确实就绪之后才向其分发服务请求，请指定一个就绪检查 readiness probe<ul>
<li>此时就绪检查的内容可能和健康检查相同</li>
<li>就绪检查适合如下几类容器：<ul>
<li>初始化时需要加载大量的数据、配置文件</li>
<li>启动时需要执行迁移任务</li>
<li>其他</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li><strong>initialDelaySeconds</strong>，它表示的是说这个 Pod 启动延迟多久进行一次检查<ul>
<li>比如说现在有一个 Java 的应用，它启动的时间可能会比较长，因为涉及到 JVM 的启动，包括 Java 自身 jar 的加载</li>
<li>所以前期可能有一段时间是没有办法被检测的，而这个时间又是可预期的，那这时可能要设置一下 initialDelaySeconds</li>
</ul>
</li>
<li><strong>periodSeconds</strong>，它表示的是检测的时间间隔<ul>
<li>正常默认的这个值是 10 秒</li>
</ul>
</li>
<li><strong>timeoutSeconds</strong>，它表示的是检测的超时时间，当超时时间之内没有检测成功，那它会认为是失败的一个状态</li>
<li><strong>successThreshold</strong>，它表示的是：当这个 pod 从探测失败到再一次判断探测成功，所需要的阈值次数<ul>
<li>默认情况下是 1 次，表示原本是失败的，那接下来探测这一次成功了，就会认为这个 Pod 是处在一个探针状态正常的一个状态</li>
</ul>
</li>
<li><strong>failureThreshold</strong>，它表示的是探测失败的重试次数<ul>
<li>默认值是 3，表示的是当从一个健康的状态连续探测 3 次失败，那此时会判断当前这个 Pod 的状态处在一个失败的状态</li>
</ul>
</li>
</ul>
<h5 id="容器的状态"><a href="#容器的状态" class="headerlink" title="容器的状态"></a>容器的状态</h5><ul>
<li>一旦 Pod 被调度到节点上，kubelet 便开始使用容器引擎（通常是 docker）创建容器</li>
<li>容器有三种可能的状态：<ul>
<li><strong>Waiting：</strong> 容器的初始状态<ul>
<li>处于 Waiting 状态的容器，仍然有对应的操作在执行，例如：拉取镜像、应用 Secrets等</li>
</ul>
</li>
<li><strong>Running：</strong> 容器处于正常运行的状态<ul>
<li>容器进入 Running 状态之后，如果指定了 postStart hook，该钩子将被执行</li>
</ul>
</li>
<li><strong>Terminated：</strong> 容器处于结束运行的状态<ul>
<li>容器进入 Terminated 状态之前，如果指定了 preStop hook，该钩子将被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h5><ul>
<li><p>定义 Pod 或工作负载时，可以指定 restartPolicy，可选的值有：</p>
<ul>
<li>Always （默认值）</li>
<li>OnFailure</li>
<li>Never</li>
</ul>
</li>
<li><p>restartPolicy 将作用于 Pod 中的所有容器</p>
</li>
<li><p>kubelete 将在五分钟内，按照递延的时间间隔（10s, 20s, 40s ……）尝试重启已退出的容器，并在十分钟后再次启动这个循环，直到容器成功启动，或者 Pod 被删除</p>
</li>
<li><p>控制器 Deployment/StatefulSet/DaemonSet 中，只支持 Always 这一个选项，不支持 OnFailure 和 Never 选项</p>
</li>
</ul>
<h4 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h4><ul>
<li><p>Pod 可以包含多个工作容器，也可以包含一个或多个初始化容器，初始化容器在工作容器启动之前执行</p>
</li>
<li><p>初始化容器与工作容器完全相同，除了如下几点：</p>
<ul>
<li>初始化容器总是运行并自动结束</li>
<li>kubelet 按顺序执行 Pod 中的初始化容器，前一个初始化容器成功结束后，下一个初始化容器才开始运行<ul>
<li>所有的初始化容器成功执行后，才开始启动工作容器</li>
</ul>
</li>
<li>如果 Pod 的任意一个初始化容器执行失败，kubernetes 将反复重启该 Pod，直到初始化容器全部成功（除非 Pod 的 restartPolicy 被设定为 Never）</li>
<li>初始化容器的 Resource request / limits 处理不同</li>
<li>初始化容器不支持 readiness probe，因为初始化容器必须在 Pod ready 之前运行并结束</li>
</ul>
</li>
<li><p>初始化容器可以指定不同于工作容器的镜像，这使得初始化容器相较于直接在工作容器中编写启动相关的代码更有优势：</p>
<ul>
<li>初始化容器可以包含工作容器中没有的工具代码或者自定义代码<ul>
<li>例如，无需仅仅为了少量的 setup 工作（使用 sed, awk, python 或 dig 进行环境设定）而重新从一个基础镜像制作另外一个镜像</li>
</ul>
</li>
<li>初始化容器可以更安全地执行某些使工作容器变得不安全的代码</li>
<li>应用程序的镜像构建者和部署者可以各自独立地工作，而无需一起构建一个镜像</li>
<li>初始化容器相较于工作容器，可以以另外一个视角处理文件系统<ul>
<li>例如，他们可以拥有访问 Secrets 的权限，而工作容器却不一定被授予该权限</li>
</ul>
</li>
<li>初始化容器在任何工作容器启动之前结束运行，这个特性使得我们可以阻止或者延迟工作容器的启动，直到某些前提条件得到满足<ul>
<li>一旦前提条件满足，所有的工作容器将同时并行启动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="初始化容器的行为"><a href="#初始化容器的行为" class="headerlink" title="初始化容器的行为"></a>初始化容器的行为</h5><ul>
<li>Pod 的启动时，首先初始化网络和数据卷，然后按顺序执行每一个初始化容器<ul>
<li>任何一个初始化容器都必须成功退出，才能开始下一个初始化容器</li>
<li>如果某一个容器启动失败或者执行失败，kubelet 将根据 Pod 的 restartPolicy 决定是否重新启动 Pod</li>
</ul>
</li>
<li>只有所有的初始化容器全都执行成功，Pod 才能进入 ready 状态<ul>
<li>初始化容器的端口是不能够通过 kubernetes Service 访问的</li>
<li>Pod 在初始化过程中处于 Pending 状态，并且同时有一个 type 为 <code>Initializing</code> status 为 <code>True</code> 的 Condition</li>
</ul>
</li>
<li>如果 Pod 重启，所有的初始化容器也将被重新执行</li>
<li>可以重启、重试、重新执行初始化容器，因此初始化容器中的代码必须是 <strong>幂等</strong> 的<ul>
<li>具体来说, 向 emptyDir 写入文件内容的代码应该考虑到该文件已经存在的情况</li>
</ul>
</li>
<li>可以组合使用就绪检查和 activeDeadlineSeconds，以防止初始化容器始终失败</li>
<li>Pod 中不能包含两个同名的容器（初始化容器和工作容器也不能同名）</li>
</ul>
<h5 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h5><p>在确定初始化容器的执行顺序以后，以下 resource 使用规则将适用：</p>
<ul>
<li>所有初始化容器中最高的 resource request/limit 是最终生效的 request/limit</li>
<li>对于 Pod 来说，最终生效的 resource request/limit 是如下几个当中较高的一个：<ul>
<li>所有工作容器某一个 resource request/limit 的和</li>
<li>最终生效的初始化容器的 request/limit 的和</li>
</ul>
</li>
<li>Kubelet 依据最终生效的 request/limit 执行调度，这意味着，在执行初始化容器时，就已经为 Pod 申请了其资源需求</li>
</ul>
<h5 id="Pod-重启的原因"><a href="#Pod-重启的原因" class="headerlink" title="Pod 重启的原因"></a>Pod 重启的原因</h5><ul>
<li>Pod 重启时，所有的初始化容器都会重新执行</li>
<li>Pod 重启的原因可能有：<ul>
<li>用户更新了 Pod 的定义，并改变了初始化容器的镜像<ul>
<li>改变任何一个初始化容器的镜像，将导致整个 Pod 重启</li>
<li>改变工作容器的镜像，将只重启该工作容器，而不重启 Pod</li>
</ul>
</li>
<li>Pod 容器基础设施被重启（例如 docker engine），这种情况不常见，通常只有 node 节点的 root 用户才可以执行此操作</li>
<li>Pod 中所有容器都已经结束，restartPolicy 是 Always，且初始化容器执行的记录已经被垃圾回收，此时将重启整个 Pod</li>
</ul>
</li>
</ul>
<h5 id="配置初始化容器"><a href="#配置初始化容器" class="headerlink" title="配置初始化容器"></a>配置初始化容器</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">init-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">workdir</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="comment"># These containers are run during pod initialization</span></span><br><span class="line"><span class="attr">  initContainers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">install</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">wget</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"-O"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"/work-dir/index.html"</span></span><br><span class="line"><span class="attr">    - https:</span><span class="string">//kuboard.cn</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">workdir</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/work-dir"</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">workdir</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Pod 中初始化容器和应用程序共享了同一个数据卷</p>
<ul>
<li>初始化容器将该共享数据卷挂载到 <code>/work-dir</code> 路径</li>
<li>应用程序容器将共享数据卷挂载到 <code>/usr/share/nginx/html</code> 路径</li>
</ul>
</li>
<li><p>初始化容器执行命令后，就退出执行</p>
<ul>
<li>执行该命令时，初始化容器将结果写入了应用程序容器 nginx 服务器对应的 html 根路径下的 <code>index.html</code></li>
</ul>
</li>
</ul>
<h5 id="Debug-初始化容器"><a href="#Debug-初始化容器" class="headerlink" title="Debug 初始化容器"></a>Debug 初始化容器</h5><ul>
<li><p>检查初始化容器的状态</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME         READY     STATUS     RESTARTS   AGE</span><br><span class="line">&lt;pod-name&gt;   0/1       Init:1/2   0          7s</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态是 <code>Init:1/2</code>，则表明了两个初始化容器当中的一个已经成功执行</p>
</li>
</ul>
</li>
<li><p>查看初始化容器的详情</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Init Containers:</span><br><span class="line">  &lt;init-container-1&gt;:</span><br><span class="line">    Container ID:    ...</span><br><span class="line">    ...</span><br><span class="line">    State:           Terminated</span><br><span class="line">      Reason:        Completed</span><br><span class="line">      Exit Code:     0</span><br><span class="line">      Started:       ...</span><br><span class="line">      Finished:      ...</span><br><span class="line">    Ready:           True</span><br><span class="line">    Restart Count:   0</span><br><span class="line">    ...</span><br><span class="line">  &lt;init-container-2&gt;:</span><br><span class="line">    Container ID:    ...</span><br><span class="line">    ...</span><br><span class="line">    State:           Waiting</span><br><span class="line">      Reason:        CrashLoopBackOff</span><br><span class="line">    Last State:      Terminated</span><br><span class="line">      Reason:        Error</span><br><span class="line">      Exit Code:     1</span><br><span class="line">      Started:       ...</span><br><span class="line">      Finished:      ...</span><br><span class="line">    Ready:           False</span><br><span class="line">    Restart Count:   3</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查看初始化容器的日志</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt; -c &lt;init-container-1&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h6 id="理解-Pod-状态"><a href="#理解-Pod-状态" class="headerlink" title="理解 Pod 状态"></a>理解 Pod 状态</h6><ul>
<li>如果 Pod 的状态以 <code>Init:</code> 开头，表示该 Pod 正在执行初始化容器</li>
<li>下表描述了 Debug 初始化容器的过程中，一些可能出现的 Pod 状态</li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Init:N/M</code></td>
<td>Pod 中包含 M 个初始化容器，其中 N 个初始化容器已经成功执行</td>
</tr>
<tr>
<td><code>Init:Error</code></td>
<td>Pod 中有一个初始化容器执行失败</td>
</tr>
<tr>
<td><code>Init:CrashLoopBackOff</code></td>
<td>Pod 中有一个初始化容器反复执行失败</td>
</tr>
<tr>
<td><code>Pending</code></td>
<td>Pod 还未开始执行初始化容器</td>
</tr>
<tr>
<td><code>PodInitializing</code> or <code>Running</code></td>
<td>Pod 已经完成初始化容器的执行</td>
</tr>
</tbody></table>
<h4 id="Disruptions-毁坏"><a href="#Disruptions-毁坏" class="headerlink" title="Disruptions (毁坏)"></a>Disruptions (毁坏)</h4><ul>
<li><p>非自愿的毁坏（involuntary disruption）</p>
<ul>
<li>节点所在物理机的硬件故障</li>
<li>集群管理员误删了虚拟机</li>
<li>云供应商或管理程序故障导致虚拟机被删</li>
<li>Linux 内核故障</li>
<li>集群所在的网络发生分片，导致节点不可用</li>
<li>节点资源耗尽，导致 Pod 被驱逐</li>
</ul>
</li>
<li><p>自愿的毁坏（voluntary disruptions）, 主要包括由应用管理员或集群管理员主动执行的操作</p>
<ul>
<li>删除 Deployment 或其他用于管理 Pod 的控制器</li>
<li>修改 Deployment 中 Pod 模板的定义，导致 Pod 重启</li>
<li>直接删除一个 Pod</li>
</ul>
</li>
</ul>
<h5 id="处理-Disruption"><a href="#处理-Disruption" class="headerlink" title="处理 Disruption"></a>处理 Disruption</h5><ul>
<li>弥补非自愿的毁坏可以采取的方法有：<ul>
<li>确保您的 Pod 申请合适的计算资源</li>
<li>如果需要高可用，为您的程序运行多个副本，参考 Deployment、StatefulSet</li>
<li>如果需要更高的高可用性，将应用程序副本分布到多个机架上（参考 anti-affinity]）或分不到多个地区（使用 multi-zone cluster）</li>
</ul>
</li>
</ul>
<h5 id="Disruption-Budget"><a href="#Disruption-Budget" class="headerlink" title="Disruption Budget"></a>Disruption Budget</h5><ul>
<li><p>Kubernetes 提供了 Disruption Budget 这一特性，以帮助我们在高频次自愿的毁坏会发生的情况下，仍然运行高可用的应用程序</p>
</li>
<li><p>应用程序管理员可以为每一个应用程序创建 <code>PodDisruptionBudget</code> 对象（PDB）</p>
<ul>
<li>PDB 限制了多副本应用程序在自愿的毁坏情况发生时，最多有多少个副本可以同时停止</li>
<li>例如，一个 web 前端的程序需要确保可用的副本数不低于总副本数的一定比例</li>
</ul>
</li>
<li><p>应该使用兼容 PodDisruption Budget 的工具（例如 <code>kubectl drain</code>，此类工具调用 <a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api" target="_blank" rel="noopener">Eviction API</a>）而不是直接删除 Pod 或者 Deployment</p>
</li>
<li><p><code>kubectl drain</code> 命令会尝试将节点上所有的 Pod 驱逐掉</p>
<ul>
<li>驱逐请求可能会临时被拒绝，<code>kubectl drain</code> 将周期性地重试失败的请求，直到节点上所有的 Pod 都以终止，或者直到超过了预先配置的超时时间</li>
</ul>
</li>
<li><p>PDB 指定了应用程序最少期望的副本数（相对于总副本数）</p>
<ul>
<li>例如，某个 Deployment 的 <code>.spec.replicas</code> 为 5，期望的副本数是 5个</li>
<li>如果他对应的 PDB 允许最低 4个副本数，则 Eviction API（<code>kubectl drain</code>）在同一时刻最多会允许 1 个自愿的毁坏，而不是 2 个或更多<ul>
<li>PDB 通过 Pod 的 <code>.metadata.ownerReferences</code> 查找到其对应的控制器（Deployment、StatefulSet）</li>
<li>PDB 通过 控制器（Deployment、StatefulSet）的 <code>.spec.replicas</code> 字段来确定期望的副本数</li>
<li>PDB 通过控制器（Deployment、StatefulSet）的 label selector 来确定哪些 Pod 属于同一个应用程序</li>
<li>PDB 不能阻止非自愿的毁坏发生，但是当这类毁坏发生时，将被计入到当前毁坏数里</li>
<li>通过 <code>kubectl drain</code> 驱逐 Pod 时，Pod 将被优雅地终止（gracefully terminated）</li>
</ul>
</li>
</ul>
</li>
<li><p>在滚动更新过程中被删除的 Pod 也将计入到 PDB 的当前毁坏数，但是控制器（例如 Deployment、StatefulSet）在执行滚动更新时，并不受 PDB 的约束</p>
<ul>
<li>滚动更新过程中，同时可以删除的 Pod 数量在控制器对象（Deployment、StatefulSet 等）的定义中规定</li>
</ul>
</li>
</ul>
<h6 id="区分集群管理员和应用管理员的角色"><a href="#区分集群管理员和应用管理员的角色" class="headerlink" title="区分集群管理员和应用管理员的角色"></a>区分集群管理员和应用管理员的角色</h6><ul>
<li><p>集群管理员和应用管理员是不同的角色，且相互之间所共有的知识并不多</p>
</li>
<li><p>对这两个角色的职责进行区分，在如下场景中是非常有用的：</p>
<ul>
<li>多个应用程序团队共享一个 Kubernetes 集群</li>
<li>第三方工具或服务将集群的管理自动化</li>
</ul>
</li>
<li><p>Pod Disruption Budget 是区分两种角色时的必要的界面，双方要就此概念达成共识</p>
</li>
<li><p>如果你所在的组织中，并不严格区分集群管理员和应用程序管理员，则并不需要使用 Pod Disruption Budget</p>
</li>
</ul>
<h6 id="如何执行毁坏性的操作（Disruptive-Action）"><a href="#如何执行毁坏性的操作（Disruptive-Action）" class="headerlink" title="如何执行毁坏性的操作（Disruptive Action）"></a>如何执行毁坏性的操作（Disruptive Action）</h6><ul>
<li>如果您是集群管理员，且需要在所有节点上执行毁坏性的操作（disruptive action），例如节点或系统软件的升级，此时可能的选择有：<ul>
<li>接受升级过程中的停机时间</li>
<li>故障转移（Failover）到另外一个集群副本<ul>
<li>无停机时间，但是将有额外的代价，因为需要由双份的节点以及更多的人力成本来管理集群之间的切换</li>
</ul>
</li>
<li>编写容错的应用程序（disruption tolerant application）并使用 PDB<ul>
<li>无停机时间</li>
<li>最少的资源冗余</li>
<li>支持更多的集群管理自动化</li>
<li>编写容错的应用程序（disruption-tolerant application）非常需要技巧，但是要容忍自愿的毁坏所做的工作与支持自动伸缩（autoscaling）与容忍非自愿的毁坏（tolerating involuntary disruption）所做的工作是大量重叠的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="配置-Pod-Disruption-Budget"><a href="#配置-Pod-Disruption-Budget" class="headerlink" title="配置 Pod Disruption Budget"></a>配置 Pod Disruption Budget</h5><ul>
<li><p><code>PodDisruptionBudget</code> 包含三个字段：</p>
<ul>
<li>标签选择器 <code>.spec.selector</code> 用于指定 PDB 适用的 Pod。此字段为必填</li>
<li><code>.spec.minAvailable</code>：当完成驱逐时，最少仍然要保留多少个 Pod 可用<ul>
<li>该字段可以是一个整数，也可以是一个百分比</li>
</ul>
</li>
<li><code>.spec.maxUnavailable</code>： 当完成驱逐时，最多可以有多少个 Pod 被终止<ul>
<li>该字段可以是一个整数，也可以是一个百分比</li>
<li>只能应用到那些有控制器的 Pod 上</li>
</ul>
</li>
</ul>
</li>
<li><p>在一个 PDB 中，只能指定 <code>maxUnavailable</code> 和 <code>minAvailable</code> 中的一个</p>
</li>
<li><p>如果指定 <code>minAvailable</code> 或 <code>maxUnavailable</code> 为百分数，其计算结果可能不会正好是一个整数</p>
<ul>
<li>Kubernetes 将向上舍入</li>
<li>假设有 7 个 Pod，<code>minAvailable</code> 设置为 <code>50%</code>，则必须有 4 个 Pod 始终可用</li>
</ul>
</li>
<li><p>PDB 只能保护应用避免受到自愿毁坏的影响，而不是所有原因的毁坏</p>
</li>
</ul>
<h6 id="确定哪个应用程序需要使用-PDB-保护"><a href="#确定哪个应用程序需要使用-PDB-保护" class="headerlink" title="确定哪个应用程序需要使用 PDB 保护"></a>确定哪个应用程序需要使用 PDB 保护</h6><ul>
<li><p>通常如下几种 Kubernetes 控制器创建的应用程序可以使用 PDB：</p>
<ul>
<li>Deployment</li>
<li>ReplicationController</li>
<li>ReplicaSet</li>
<li>StatefulSet</li>
</ul>
</li>
<li><p>PDB 中 <code>.spec.selector</code> 字段的内容必须与控制器中 <code>.spec.selector</code> 字段的内容相同</p>
</li>
<li><p>也可以直接为 Pod 设置 PDB，但是存在一些限制条件</p>
<ul>
<li>只能使用 <code>.spec.minAvailable</code>，不能使用 <code>.spec.maxUnavailable</code></li>
<li><code>.spec.minAvailable</code> 字段中只能使用整型数字，不能使用百分比</li>
</ul>
</li>
</ul>
<h6 id="思考应用程序如何处理毁坏（disruption）"><a href="#思考应用程序如何处理毁坏（disruption）" class="headerlink" title="思考应用程序如何处理毁坏（disruption）"></a>思考应用程序如何处理毁坏（disruption）</h6><ul>
<li>当自愿毁坏发生时，在短时间内应用程序最多可以容许多少个实例被终止<ul>
<li>无状态的前端：<ul>
<li>关注点：不能让服务能力（serving capacity）降低超过 10%</li>
<li>解决方案：在 PDB 中配置 minAvailable 90%</li>
</ul>
</li>
<li>单实例有状态应用：<ul>
<li>关注点：未经同意不能关闭此应用程序</li>
<li>解决方案1： 不使用 PDB，并且容忍偶尔的停机</li>
<li>解决方案2： 在 PDB 中设置 maxUnavailable=0<ul>
<li>与集群管理员达成一致，请集群管理员在终止应用之前与你沟通</li>
<li>当集群管理员联系你时，准备好停机时间，删除 PDB 以表示已准备好应对毁坏。并做后续处理</li>
</ul>
</li>
</ul>
</li>
<li>多实例有状态应用，例如 consul、zookeeper、etcd：<ul>
<li>关注点：不能将实例数降低到某个数值，否则写入会失败</li>
<li>解决方案1： 在 PDB 中设置 maxUnavailable 为 1 （如果副本数会发生变化，可以使用此设置）</li>
<li>解决方案2： 在 PDB 中设置 minAvailable 为最低数量（可以同时容忍更多的毁坏数）</li>
</ul>
</li>
<li>可以重新开始的批处理任务：<ul>
<li>关注点：当发生自愿毁坏时，Job 仍然需要完成其执行任务</li>
<li>解决方案： 不创建 PDB。Job 控制器将会创建一个 Pod 用于替换被毁坏的 Pod</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="问题诊断"><a href="#问题诊断" class="headerlink" title="问题诊断"></a>问题诊断</h4><h5 id="常见应用异常"><a href="#常见应用异常" class="headerlink" title="常见应用异常"></a>常见应用异常</h5><h6 id="Pod-停留在-Pending"><a href="#Pod-停留在-Pending" class="headerlink" title="Pod 停留在 Pending"></a>Pod 停留在 Pending</h6><ul>
<li>pending 表示调度器没有进行介入</li>
<li>此时可以通过 <code>kubectl describe pod</code> 来查看相应的事件<ul>
<li>如果由于资源或者说端口占用，或者是由于 node selector 造成 pod 无法调度的时候，可以在相应的事件里面看到相应的结果，这个结果里面会表示说有多少个不满足的 node，有多少是因为 CPU 不满足，有多少是由于 node 不满足，有多少是由于 tag 打标造成的不满足</li>
</ul>
</li>
</ul>
<h6 id="Pod-停留在-waiting"><a href="#Pod-停留在-waiting" class="headerlink" title="Pod 停留在 waiting"></a>Pod 停留在 waiting</h6><ul>
<li>pod 的 states 处在 waiting 的时候，通常表示说这个 pod 的镜像没有正常拉取<ul>
<li>可能是由于这个镜像是私有镜像，但是没有配置 Pod secret</li>
<li>可能由于这个镜像地址是不存在的，造成这个镜像拉取不下来</li>
<li>这个镜像可能是一个公网的镜像，造成镜像的拉取失败</li>
</ul>
</li>
</ul>
<h6 id="Pod-不断被拉取并且可以看到-crashing"><a href="#Pod-不断被拉取并且可以看到-crashing" class="headerlink" title="Pod 不断被拉取并且可以看到 crashing"></a>Pod 不断被拉取并且可以看到 crashing</h6><ul>
<li>pod 不断被拉起，而且可以看到类似像 backoff </li>
<li>这个通常表示说 pod 已经被调度完成了，但是启动失败<ul>
<li>这个时候通常要关注的应该是这个应用自身的一个状态，并不是说配置是否正确、权限是否正确</li>
<li>此时需要查看的应该是 pod 的具体日志</li>
</ul>
</li>
</ul>
<h6 id="Pod-处在-Runing-但是没有正常工作"><a href="#Pod-处在-Runing-但是没有正常工作" class="headerlink" title="Pod 处在 Runing 但是没有正常工作"></a>Pod 处在 Runing 但是没有正常工作</h6><ul>
<li>此时比较常见的一个点就可能是由于一些非常细碎的配置，类似像有一些字段可能拼写错误，造成了 yaml 下发下去了，但是有一段没有正常地生效，从而使得这个 pod 处在 running 的状态没有对外服务，那此时可以通过 <code>apply-validate-f pod.yaml</code> 的方式来进行判断当前 yaml 是否是正常的</li>
<li>如果 yaml 没有问题，那么接下来可能要诊断配置的端口是否是正常的，以及 Liveness 或 Readiness 是否已经配置正确</li>
</ul>
<h6 id="Service-无法正常的工作"><a href="#Service-无法正常的工作" class="headerlink" title="Service 无法正常的工作"></a>Service 无法正常的工作</h6><ul>
<li>比较常见的 service 出现问题的时候，是自己的使用上面出现了问题</li>
<li>因为 service 和底层的 pod 之间的关联关系是通过 selector 的方式来匹配的，也就是说 pod 上面配置了一些 label，然后 service 通过 match label 的方式和这个 pod 进行相互关联</li>
<li>如果这个 label 配置的有问题，可能会造成这个 service 无法找到后面的 endpoint，从而造成相应的 service 没有办法对外提供服务，那如果 service 出现异常的时候，第一个要看的是这个 service 后面是不是有一个真正的 endpoint，其次来看这个 endpoint 是否可以对外提供正常的服务</li>
</ul>
<h5 id="应用远程调试"><a href="#应用远程调试" class="headerlink" title="应用远程调试"></a>应用远程调试</h5><h6 id="Pod-远程调试"><a href="#Pod-远程调试" class="headerlink" title="Pod 远程调试"></a>Pod 远程调试</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pod 中只有一个容器时</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pod 中有多个容器时</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name -c container-name /bin/bash</span><br></pre></td></tr></table></figure>

<h6 id="Servic-远程调试"><a href="#Servic-远程调试" class="headerlink" title="Servic 远程调试"></a>Servic 远程调试</h6><ul>
<li><p>service 的远程调试其实分为两个部分：</p>
<ul>
<li><p>想将一个服务暴露到远程的一个集群之内，让远程集群内的一些应用来去调用本地的一个服务，这是一条反向的一个链路</p>
<ul>
<li><p>开源组件 <a href="https://www.telepresence.io/" target="_blank" rel="noopener">Telepresence</a> 可以将本地的应用代理到远程集群中的一个 service 上面</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telepresence --swap-deployment <span class="variable">$Deployment_Name</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>想让这个本地服务能够去调远程的服务，那么这是一条正向的链路</p>
<ul>
<li><p>可以通过 port-forward 的方式将远程的应用调用到本地的端口之上</p>
</li>
<li><p>比如现在远程有一个 API server 提供了一些接口，本地在调试 Code 时候，想要直接调用这个 API server</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward svc/app -n app-namespace</span><br></pre></td></tr></table></figure>
</li>
<li><p>它的使用方式是 kubectl port-forward，然后 service 加上远程的 service name，再加上相应的 namespace，后面还可以加上一些额外的参数，比如说端口的一个映射，通过这种机制就可以把远程的一个应用代理到本地的端口之上，此时通过访问本地端口就可以访问远程的服务</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="kubectl-debug"><a href="#kubectl-debug" class="headerlink" title="kubectl-debug"></a>kubectl-debug</h6><ul>
<li>通常情况下应用的镜像里并不会带特别多的调试工具，类似像 netstat telnet 等等这些 ，因为这个会造成应用整体非常冗余</li>
<li>那么如果想要调试的时候就可以依赖类似于像 kubectl-debug 这样一个工具</li>
<li>kubectl-debug 是依赖于 Linux namespace 的方式来去做的<ul>
<li>它可以 datash 一个 Linux namespace 到一个额外的 container，然后在这个 container 里面执行任何的 debug 动作</li>
<li>其实和直接去 debug 这个 Linux namespace 是一致的</li>
</ul>
</li>
</ul>
<h3 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller  (控制器)"></a>Controller  (控制器)</h3><ul>
<li>Kubernetes 通过引入控制器的概念来管理 Pod 实例</li>
<li>应该始终通过创建 Controller 来创建 Pod，而不是直接创建 Pod</li>
<li>控制器可以提供如下特性：<ul>
<li>水平扩展（运行 Pod 的多个副本）</li>
<li>rollout（版本更新）</li>
<li>self-healing（故障恢复） <ul>
<li>例如当一个节点出现故障，控制器可以自动地在另一个节点调度一个配置完全一样的 Pod，以替换故障节点上的 Pod</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><ul>
<li>ReplicaSet 用来维护一个数量稳定的 Pod 副本集合，可以保证某种定义一样的 Pod 始终有指定数量的副本数在运行</li>
</ul>
<h5 id="ReplicaSet-的定义"><a href="#ReplicaSet-的定义" class="headerlink" title="ReplicaSet 的定义"></a>ReplicaSet 的定义</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># modify replicas according to your case</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>与其他 Kubernetes 对象一样，ReplicaSet 需要的字段有：</p>
<ul>
<li><code>apiVersion</code>：apps/v1</li>
<li><code>kind</code>：ReplicaSet</li>
<li><code>metadata</code></li>
<li><code>spec</code>： ReplicaSet 的详细定义<ul>
<li><code>template</code>： Pod 模板，在 ReplicaSet 使用 Pod 模板的定义创建新的 Pod<ul>
<li>必须定义 <code>.spec.template.metadata.labels</code> 字段<ul>
<li>该字段不要与其他控制器的 selector 重合，以免这些控制器尝试接管该 Pod</li>
</ul>
</li>
<li><code>.spec.template.spec.restartPolicy</code> 的默认值为 <code>Always</code></li>
</ul>
</li>
<li><code>selector</code>： 用于识别可以接管哪些 Pod<ul>
<li><code>.spec.template.metadata.labels</code> 必须与 <code>.spec.selector</code> 匹配，否则将不能成功创建 ReplicaSet</li>
<li>如果两个 ReplicaSet 指定了相同的 <code>.spec.selector</code> 但是不同的 <code>.spec.template.metadata.labels</code> 和不同的 <code>.spec.tempalte.spec</code> 字段，两个 ReplicaSet 都将忽略另外一个 ReplicaSet 创建的 Pod</li>
</ul>
</li>
<li><code>replicas</code>： 副本数，用于指定该 ReplicaSet 应该维持多少个 Pod 副本<ul>
<li>默认值为 1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><ul>
<li>最常用的用于部署无状态服务的方式, 使得能够以声明的方式更新 Pod（容器组）和 ReplicaSet（副本集）</li>
</ul>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>可以为该命令增加 –record 选项，此时 kubectl 会将 <code>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml --record</code> 写入 Deployment 的 annotation（注解） <code>kubernetes.io/change-cause</code> 中</li>
<li>这样可以回顾某一个 Deployment 版本变化的原因</li>
</ul>
</li>
</ul>
<h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><ul>
<li><p>执行以下命令，将容器镜像从 nginx:1.7.9 更新到 nginx:1.9.1</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl --record deployment.apps/nginx-deployment <span class="built_in">set</span> image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>或者可以 <code>edit</code> 该 Deployment，并将 <code>.spec.template.spec.containers[0].image</code> 从 <code>nginx:1.7.9</code> 修改为 <code>nginx:1.9.1</code></p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit deployment.v1.apps/nginx-deployment</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Deployment 将确保更新过程中，任意时刻只有一定数量的 Pod 被关闭</p>
<ul>
<li>默认情况下，确保至少 <code>.spec.replicas</code> 的 75% 的 Pod 保持可用（25% max unavailable）</li>
</ul>
</li>
<li><p>Deployment 将确保更新过程中，任意时刻只有一定数量的 Pod 被创建</p>
<ul>
<li>默认情况下，确保最多 <code>.spec.replicas</code> 的 25% 的 Pod 被创建（25% max surge）</li>
</ul>
</li>
</ul>
<h6 id="覆盖更新-Rollover-（更新过程中再更新）"><a href="#覆盖更新-Rollover-（更新过程中再更新）" class="headerlink" title="覆盖更新 Rollover （更新过程中再更新）"></a>覆盖更新 Rollover （更新过程中再更新）</h6><ul>
<li>每创建一个 Deployment，Deployment Controller 都为其创建一个 ReplicaSet，并设定其副本数为期望的 Pod 数（ <code>.spec.replicas</code> 字段）</li>
<li>如果 Deployment 被更新，旧的 ReplicaSet 将被 Scale down，新建的 ReplicaSet 将被 Scale up<ul>
<li>直到最后新旧两个 ReplicaSet，一个副本数为 <code>.spec.replias</code>，另一个副本数为 0</li>
<li>这个过程称为 rollout</li>
</ul>
</li>
<li>当 Deployment 的 rollout 正在进行中的时候，如果再次更新 Deployment 的信息，此时 Deployment 将再创建一个新的 ReplicaSet 并开始将其 scale up，将先前正在 scale up 的 ReplicaSet 也作为一个旧的 ReplicaSet，并开始将其 scale down<ul>
<li>假设创建了一个 Deployment 有 5 个 nginx:1.7.9 的副本</li>
<li>立刻更新该 Deployment 使得其 <code>.spec.replicas</code> 为 5，容器镜像为 nginx:1.9.1，而此时只有 3 个 nginx:1.7.9 的副本已创建</li>
<li>此时 Deployment Controller 将立刻开始 kill 已经创建的 3 个 nginx:1.7.9 的 Pod，并开始创建 nginx:1.9.1 的 Pod</li>
<li>Deployment Controller 不会等到 5 个 nginx:1.7.9 的 Pod 都创建完之后在开始新的更新</li>
</ul>
</li>
</ul>
<h6 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h6><ul>
<li>通过 Deployment 中 <code>.spec.strategy</code> 字段，可以指定使用 <code>滚动更新 RollingUpdate</code> 的部署策略还是使用 <code>重新创建 Recreate</code> 的部署策略</li>
<li><code>.spec.strategy.type</code><ul>
<li>Recreate<ul>
<li>Deployment 将先删除原有副本集中的所有 Pod，然后再创建新的副本集和新的 Pod</li>
<li>如此更新过程中将出现一段应用程序不可用的情况</li>
</ul>
</li>
<li>RollingUpdate<ul>
<li>滚动更新</li>
<li><code>.spec.strategy.minReadySeconds</code>:<ul>
<li>Kubernetes 在等待设置的时间后才进行升级</li>
<li>如果没有设置该值，Kubernetes 会假设该容器启动起来后就提供服务了</li>
<li>如果没有设置该值，在某些极端情况下可能会造成服务不正常运行</li>
</ul>
</li>
<li><code>.spec.strategy.maxSurge</code>:<ul>
<li>数字或百分比, 默认值为 25%</li>
<li>升级过程中最多可以比原先设置多出的 Pod 数量</li>
<li>例如：maxSurage=1，replicas=5, 则表示 Kubernetes 会先启动 1 个新的 Pod 后才删掉一个旧的 Pod，整个升级过程中最多会有 5+1 个 Pod</li>
</ul>
</li>
<li><code>.spec.strategy.maxUnavaible</code>:<ul>
<li>数字或百分比, 默认值为 25%</li>
<li>升级过程中最多有多少个 Pod 处于无法提供服务的状态</li>
<li>当 <code>maxSurge</code> 不为 0 时，该值也不能为 0</li>
<li>例如：maxUnavaible=1，则表示 Kubernetes 整个升级过程中最多会有 1 个 Pod 处于无法服务的状态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h5><ul>
<li><p>当且仅当 Deployment 的 <code>.spec.template</code> 字段被修改时，K8s 将为其创建一个 Deployment revision（版本）</p>
<ul>
<li>通过 Deployment 中 <code>.spec.revisionHistoryLimit</code> 字段，可指定为该 Deployment 保留多少个旧的 ReplicaSet<ul>
<li>超出该数字的将被在后台进行垃圾回收</li>
<li>该字段的默认值是 10</li>
</ul>
</li>
</ul>
</li>
<li><p>执行命令 <code>kubectl rollout history deployment.v1.apps/nginx-deployment</code> 检查 Deployment 的历史版本</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deployments <span class="string">"nginx-deployment"</span></span><br><span class="line">REVISION    CHANGE-CAUSE</span><br><span class="line">1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=<span class="literal">true</span></span><br><span class="line">2           kubectl <span class="built_in">set</span> image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=<span class="literal">true</span></span><br><span class="line">3           kubectl <span class="built_in">set</span> image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过如下方式制定 <strong>CHANGE-CAUSE</strong> 信息：</p>
<ul>
<li>为 Deployment 增加注解，<code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause=&quot;image updated to 1.9.1&quot;</code></li>
<li>执行 kubectl apply 命令时，增加 <code>--record</code> 选项</li>
<li>手动编辑 Deployment 的 <code>.metadata.annotation</code> 信息</li>
</ul>
</li>
</ul>
</li>
<li><p>执行命令 <code>kubectl rollout history deployment.v1.apps/nginx-deployment --revision=2</code>，查看 revision（版本）的详细信息</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deployments <span class="string">"nginx-deployment"</span> revision 2</span><br><span class="line">  Labels:       app=nginx</span><br><span class="line">          pod-template-hash=1159050644</span><br><span class="line">  Annotations:  kubernetes.io/change-cause=kubectl <span class="built_in">set</span> image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=<span class="literal">true</span></span><br><span class="line">  Containers:</span><br><span class="line">  nginx:</span><br><span class="line">    Image:      nginx:1.9.1</span><br><span class="line">    Port:       80/TCP</span><br><span class="line">    QoS Tier:</span><br><span class="line">        cpu:      BestEffort</span><br><span class="line">        memory:   BestEffort</span><br><span class="line">    Environment Variables:      &lt;none&gt;</span><br><span class="line">  No volumes.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>执行命令 <code>kubectl rollout undo deployment.v1.apps/nginx-deployment</code> 将当前版本回滚到前一个版本</p>
<ul>
<li><p>也可以使用 <code>--to-revision</code> 选项回滚到前面的某一个指定版本</p>
<ul>
<li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="伸缩"><a href="#伸缩" class="headerlink" title="伸缩"></a>伸缩</h5><ul>
<li>执行命令 <code>kubectl scale deployment.v1.apps/nginx-deployment --replicas=10</code>，可以伸缩 Deployment</li>
</ul>
<h5 id="暂停和继续"><a href="#暂停和继续" class="headerlink" title="暂停和继续"></a>暂停和继续</h5><ul>
<li>可以先暂停 Deployment，然后再触发一个或多个更新，最后再继续（resume）该 Deployment</li>
<li>这种做法使得可以在暂停和继续中间对 Deployment 做多次更新，而无需触发不必要的滚动更新</li>
<li>执行命令 <code>kubectl rollout pause deployment.v1.apps/nginx-deployment</code> 暂停 Deployment</li>
<li>暂停 Deployment 之前的信息当前仍然在起作用，而暂停 Deployment 之后，修改的 Deployment 信息尚未生效，因为该 Deployment 被暂停了</li>
<li>执行命令 <code>kubectl rollout resume deployment.v1.apps/nginx-deployment</code>，继续（resume）该 Deployment，可使前面所有的变更一次性生效</li>
<li>不能回滚（rollback）一个已暂停的 Deployment，除非继续（resume）该 Deployment</li>
</ul>
<h5 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h5><h6 id="Progressing-状态"><a href="#Progressing-状态" class="headerlink" title="Progressing 状态"></a>Progressing 状态</h6><ul>
<li>当如下任何一个任务正在执行时，Kubernete 将 Deployment 的状态标记为 <strong><em>progressing</em></strong>：<ul>
<li>Deployment 创建了一个新的 ReplicaSet</li>
<li>Deployment 正在 scale up 其最新的 ReplicaSet</li>
<li>Deployment 正在 scale down 其旧的 ReplicaSet</li>
<li>新的 Pod 变为 <strong><em>就绪（ready）</em></strong> 或 <strong><em>可用（available）</em></strong></li>
</ul>
</li>
<li>可以使用命令 <code>kubectl rollout status</code> 监控 Deployment 滚动更新的过程</li>
</ul>
<h6 id="Complete-状态"><a href="#Complete-状态" class="headerlink" title="Complete 状态"></a>Complete 状态</h6><ul>
<li>如果 Deployment 符合以下条件，Kubernetes 将其状态标记为 <strong><em>complete</em></strong>：<ul>
<li>该 Deployment 中的所有 Pod 副本都已经被更新到指定的最新版本</li>
<li>该 Deployment 中的所有 Pod 副本都处于 <strong><em>可用（available）</em></strong> 状态</li>
<li>该 Deployment 中没有旧的 ReplicaSet 正在运行</li>
</ul>
</li>
</ul>
<h6 id="Failed-状态"><a href="#Failed-状态" class="headerlink" title="Failed 状态"></a>Failed 状态</h6><ul>
<li><p>Deployment 在更新其最新的 ReplicaSet 时，可能卡住而不能达到 <strong><em>complete</em></strong> 状态</p>
</li>
<li><p>如下原因都可能导致此现象发生：</p>
<ul>
<li>集群资源不够</li>
<li>就绪检查（readiness probe）失败</li>
<li>镜像抓取失败</li>
<li>权限不够</li>
<li>资源限制</li>
<li>应用程序的配置错误导致启动失败</li>
</ul>
</li>
<li><p>指定  <code>.spec.progressDeadlineSeconds</code> 字段，Deployment Controller 在等待指定的时长后，将标记为处理失败</p>
</li>
<li><p>如果暂停了 Deployment，Kubernetes 将不会检查 <code>.spec.progressDeadlineSeconds</code></p>
</li>
</ul>
<h5 id="金丝雀发布（灰度发布）"><a href="#金丝雀发布（灰度发布）" class="headerlink" title="金丝雀发布（灰度发布）"></a>金丝雀发布（灰度发布）</h5><ul>
<li><p>创建新旧两个版本的 Deployment, 拥有相同的 label </p>
</li>
<li><p>将 Service 的 LabelSelector 设置为新旧 Deployment 所共有的 label </p>
</li>
<li><p>在新旧版本之间，流量分配的比例为两个版本副本数的比例</p>
</li>
<li><p>按照 Kubernetes 默认支持的这种方式进行金丝雀发布，有一定的局限性：</p>
<ul>
<li>不能根据用户注册时间、地区等请求中的内容属性进行流量分配</li>
<li>同一个用户如果多次调用该 Service，有可能第一次请求到了旧版本的 Pod，第二次请求到了新版本的 Pod</li>
</ul>
</li>
<li><p>Kubernetes Service 只在 TCP 层面解决负载均衡的问题，并不对请求响应的消息内容做任何解析和识别</p>
</li>
<li><p>如果想要更完善地实现金丝雀发布，可以考虑如下三种选择：</p>
<ul>
<li>业务代码编码实现</li>
<li>Spring Cloud 灰度发布</li>
<li>Istio 灰度发布</li>
</ul>
</li>
</ul>
<h4 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h4><ul>
<li><p>用于管理 Stateful（有状态）的应用程序</p>
</li>
<li><p>StatefulSet 管理 Pod 时，确保其 Pod 有一个按顺序增长的 ID</p>
</li>
<li><p>与 Deployment 最大的不同在于 StatefulSet 始终将一系列不变的名字分配给其 Pod</p>
<ul>
<li>这些 Pod 从同一个模板创建，但是并不能相互替换：每个 Pod 都对应一个特有的持久化存储标识</li>
</ul>
</li>
<li><p>对于有如下要求的应用程序，StatefulSet 非常适用：</p>
<ul>
<li>稳定、唯一的网络标识（dnsname）</li>
<li>每个 Pod 始终对应各自的存储路径（PersistantVolumeClaimTemplate）</li>
<li>按顺序地增加副本、减少副本，并在减少副本时执行清理</li>
<li>按顺序自动地执行滚动更新</li>
</ul>
</li>
<li><p>限制</p>
<ul>
<li>Pod 的存储要么由 storage class 对应的 <a href="https://github.com/kubernetes/examples/blob/master/staging/persistent-volume-provisioning/README.md" target="_blank" rel="noopener">PersistentVolume Provisioner</a> 提供，要么由集群管理员事先创建</li>
<li>删除或 scale down 一个 StatefulSet 将不会删除其对应的数据卷<ul>
<li>这样做的考虑是数据安全</li>
</ul>
</li>
<li>删除 StatefulSet 时，将无法保证 Pod 的终止是正常的<ul>
<li>如果要按顺序 gracefully 终止 StatefulSet 中的 Pod，可以在删除 StatefulSet 前将其 scale down 到 0</li>
</ul>
</li>
<li>当使用默认的 <a href="https://kuboard.cn/learning/k8s-intermediate/workload/wl-statefulset/update.html" target="_blank" rel="noopener">Pod Management Policy</a> (OrderedReady) 进行滚动更新时，可能进入一个错误状态，并需要<a href="https://kuboard.cn/learning/k8s-intermediate/workload/wl-statefulset/update.html" target="_blank" rel="noopener">人工介入</a>才能修复</li>
</ul>
</li>
</ul>
<h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span> <span class="comment"># has to match .spec.template.metadata.labels</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span> <span class="comment"># by default is 1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span> <span class="comment"># has to match .spec.selector.matchLabels</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">  - metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      accessModes:</span> <span class="string">[</span> <span class="string">"ReadWriteOnce"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      storageClassName:</span> <span class="string">"my-storage-class"</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        requests:</span></span><br><span class="line"><span class="attr">          storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure>

<h5 id="Pod-的标识"><a href="#Pod-的标识" class="headerlink" title="Pod 的标识"></a>Pod 的标识</h5><ul>
<li>StatefulSet 中的 Pod 具备一个唯一标识，该标识由以下几部分组成：<ul>
<li>序号</li>
<li>稳定的网络标识</li>
<li>稳定的存储</li>
</ul>
</li>
<li>该标识始终与 Pod 绑定，无论该 Pod 被调度（重新调度）到哪一个节点上</li>
</ul>
<h6 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h6><ul>
<li>假设一个 StatefulSet 的副本数为 N，其中的每一个 Pod 都会被分配一个序号，序号的取值范围从 0 到 N - 1，并且该序号在 StatefulSet 内部是唯一的</li>
</ul>
<h6 id="稳定的网络-ID"><a href="#稳定的网络-ID" class="headerlink" title="稳定的网络 ID"></a>稳定的网络 ID</h6><ul>
<li>StatefulSet 中 Pod 的 hostname 格式为 $(StatefulSet name)-$(Pod 序号)<ul>
<li>上面的例子将要创建三个 Pod，其名称分别为： web-0，web-1，web-2</li>
</ul>
</li>
<li>StatefulSet 可以使用 Headless Service 来控制其 Pod 所在的域<ul>
<li>Headless Service 为 <code>.spec.clusterIP: None</code> 的 Service</li>
<li>该域（domain）的格式为 $(service name).$(namespace).svc.cluster.local，其中 “cluster.local” 是集群的域</li>
</ul>
</li>
<li>StatefulSet 中每一个 Pod 将被分配一个 dnsName，格式为： $(podName).$(所在域名)</li>
</ul>
<h6 id="稳定的存储"><a href="#稳定的存储" class="headerlink" title="稳定的存储"></a>稳定的存储</h6><ul>
<li>Kubernetes 为每一个 VolumeClaimTemplate 创建一份 PersistentVolume（存储卷）<ul>
<li>在上面的例子中，每一个 Pod 都将由 StorageClass（存储类）<code>my-storage-class</code> 为其创建一个 1Gib 大小的 PersistentVolume（存储卷）</li>
<li>当 Pod 被调度（或重新调度）到一个节点上，其挂载点将挂载该存储卷声明（关联到该 PersistentVolume）</li>
</ul>
</li>
<li>当 Pod 或 StatefulSet 被删除时，其关联的 PersistentVolumeClaim（存储卷声明）以及其背后的 PersistentVolume（存储卷）仍然存在<ul>
<li>如果相同的 Pod 或 StatefulSet 被再次创建，则新建的名为 web-0 的 Pod 仍将挂载到原来名为 web-0 的 Pod 所挂载的存储卷声明及存储卷</li>
<li>这确保了 web-0、web-1、web-2 等，不管被删除重建多少次，都将 “稳定” 的使用各自所对应的存储内容</li>
</ul>
</li>
</ul>
<h5 id="部署和伸缩"><a href="#部署和伸缩" class="headerlink" title="部署和伸缩"></a>部署和伸缩</h5><ul>
<li>在创建一个副本数为 N 的 StatefulSet 时，其 Pod 将被按 {0 … N-1} 的顺序逐个创建</li>
<li>在删除一个副本数为 N 的 StatefulSet （或其中所有的 Pod）时，其 Pod 将按照相反的顺序（即 {N-1 … 0}）终止和删除</li>
<li>在对 StatefulSet 执行扩容（scale up）操作时，新增 Pod 所有的前序 Pod 必须处于 Running（运行）和 Ready（就绪）的状态</li>
<li>终止和删除 StatefulSet 中的某一个 Pod 时，该 Pod 所有的后序 Pod 必须全部已终止</li>
<li>StatefulSet 中 <code>pod.spec.terminationGracePeriodSeconds</code> 不能为 0</li>
</ul>
<h6 id="Pod-管理策略"><a href="#Pod-管理策略" class="headerlink" title="Pod 管理策略"></a>Pod 管理策略</h6><ul>
<li>可以为 StatefulSet 设定 <code>.spec.podManagementPolicy</code> 字段，以便可以继续使用 StatefulSet 唯一 ID 的特性，但禁用其有序创建和销毁 Pod 的特性<ul>
<li><strong>OrderedReady</strong><ul>
<li>OrderedReady 是 <code>.spec.podManagementPlicy</code> 的默认值, 就是按前面介绍的顺序执行</li>
</ul>
</li>
<li><strong>Parallel</strong><ul>
<li>StatefulSet Controller 将同时并行地创建或终止其所有的 Pod</li>
<li>此时 StatefulSet Controller 将不会逐个创建 Pod，等待 Pod 进入 Running 和 Ready 状态之后再创建下一个 Pod，也不会逐个终止 Pod</li>
</ul>
</li>
</ul>
</li>
<li>此选项只影响到伸缩（scale up/scale down）操作, 更新操作不受影响</li>
</ul>
<h5 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h5><ul>
<li><p>可以为 StatefulSet 设定 <code>.spec.updateStrategy</code> 字段，以便可以在改变 StatefulSet 中 Pod 的某些字段时（container/labels/resource request/resource limit/annotation 等）禁用滚动更新</p>
</li>
<li><p>OnDelete</p>
<ul>
<li>OnDelete 策略实现了 StatefulSet 的遗留版本（kuberentes 1.6及以前的版本）的行为</li>
<li>如果 StatefulSet 的 <code>.spec.updateStrategy.type</code> 字段被设置为 OnDelete<ul>
<li>修改 <code>.spec.template</code> 的内容时，StatefulSet Controller 将不会自动更新其 Pod</li>
<li>必须手工删除 Pod，此时 StatefulSet Controller 在重新创建 Pod 时，使用修改过的 <code>.spec.template</code> 的内容创建新 Pod</li>
</ul>
</li>
</ul>
</li>
<li><p>RollingUpdate</p>
<ul>
<li><p><code>.spec.updateStrategy.type</code> 字段的默认值是 RollingUpdate</p>
</li>
<li><p>在用户更新 StatefulSet 的 <code>.spec.tempalte</code> 字段时，StatefulSet Controller 将自动地删除并重建 StatefulSet 中的每一个 Pod</p>
</li>
<li><p>从序号最大的 Pod 开始，逐个删除和更新每一个 Pod，直到序号最小的 Pod 被更新</p>
</li>
<li><p>当正在更新的 Pod 达到了 Running 和 Ready 的状态之后，才继续更新其前序 Pod</p>
</li>
<li><p><strong>Partitions</strong></p>
<ul>
<li>通过指定 <code>.spec.updateStrategy.rollingUpdate.partition</code> 字段，可以分片（partitioned）执行 RollingUpdate 更新策略</li>
<li>当更新 StatefulSet 的 <code>.spec.template</code> 时：<ul>
<li>序号大于或等于 <code>.spec.updateStrategy.rollingUpdate.partition</code> 的 Pod 将被删除重建</li>
<li>序号小于 <code>.spec.updateStrategy.rollingUpdate.partition</code> 的 Pod 将不会更新，及时手工删除该 Pod，kubernetes 也会使用前一个版本的 <code>.spec.template</code> 重建该 Pod</li>
<li>如果 <code>.spec.updateStrategy.rollingUpdate.partition</code> 大于 <code>.spec.replicas</code>，更新 <code>.spec.tempalte</code> 将不会影响到任何 Pod</li>
</ul>
</li>
<li>大部分情况下不需要使用 <code>.spec.updateStrategy.rollingUpdate.partition</code>，除非碰到如下场景：<ul>
<li>执行预发布</li>
<li>执行金丝雀更新</li>
<li>执行按阶段的更新</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Forced Rollback</strong></p>
<ul>
<li><p>当使用默认的 Pod 管理策略时（OrderedReady），很有可能会进入到一种卡住的状态，需要人工干预才能修复</p>
</li>
<li><p>如果更新 Pod template 后，该 Pod 始终不能进入 Running 和 Ready 的状态（例如，镜像错误或应用程序配置错误），StatefulSet 将停止滚动更新并一直等待</p>
</li>
<li><p>此时如果仅仅将 Pod template 回退到一个正确的配置仍然是不够的</p>
<ul>
<li>由于一个已知的问题，StatefulSet 将继续等待出错的 Pod 进入就绪状态（该状态将永远无法出现），才尝试将该 Pod 回退到正确的配置</li>
</ul>
</li>
<li><p>在修复 Pod template 以后，还必须删除掉所有已经尝试使用有问题的 Pod template 的 Pod</p>
<ul>
<li>StatefulSet 此时才会开始使用修复了的 Pod template 重建 Pod</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><ul>
<li>DaemonSet 控制器确保所有（或一部分）的节点都运行了一个指定的 Pod 副本<ul>
<li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li>
<li>当节点从集群中移除时，Pod 也就被垃圾回收了</li>
<li>删除一个 DaemonSet 可以清理所有由其创建的 Pod</li>
</ul>
</li>
<li>DaemonSet 的典型使用场景有：<ul>
<li>在每个节点上运行集群的存储守护进程，例如 glusterd、ceph</li>
<li>在每个节点上运行日志收集守护进程，例如 fluentd、logstash</li>
<li>在每个节点上运行监控守护进程，例如 <a href="https://github.com/prometheus/node_exporter" target="_blank" rel="noopener">Prometheus Node Exporter</a>、<a href="https://sysdigdocs.atlassian.net/wiki/spaces/Platform" target="_blank" rel="noopener">Sysdig Agent</a>、collectd、<a href="https://www.dynatrace.com/technologies/kubernetes-monitoring/" target="_blank" rel="noopener">Dynatrace OneAgent</a>、<a href="https://docs.appdynamics.com/display/CLOUD/Container+Visibility+with+Kubernetes" target="_blank" rel="noopener">APPDynamics Agent</a>、<a href="https://docs.datadoghq.com/agent/kubernetes/daemonset_setup/" target="_blank" rel="noopener">Datadog agent</a>、<a href="https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/kubernetes-installation-configuration" target="_blank" rel="noopener">New Relic agent</a>、Ganglia gmond、<a href="https://www.instana.com/supported-integrations/kubernetes-monitoring/" target="_blank" rel="noopener">Instana Agent</a> 等</li>
</ul>
</li>
<li>通常情况下，一个 DaemonSet 将覆盖所有的节点<ul>
<li>复杂一点儿的用法，可能会为某一类守护进程设置多个 DaemonSets，每一个 DaemonSet 针对不同类硬件类型设定不同的内存、cpu请求</li>
</ul>
</li>
</ul>
<h5 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">fluentd-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      tolerations:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">        effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">fluent/fluentd-kubernetes-daemonset:v1.7.1-debian-syslog-1.0</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/var/lib/docker/containers</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>DaemonSet 的 <code>.spec.template.spec.restartPolicy</code> 字段必须为 Always，或者不填（默认值为 Always）</p>
</li>
<li><p>默认通过 Kubernetes 调度器来调度 DaemonSet 的 Pod</p>
</li>
<li><p>DaemonSet Controller 会向 DaemonSet 的 Pod 添加 <code>.spec.nodeAffinity</code> 字段，而不是 <code>.spec.nodeName</code> 字段</p>
<ul>
<li><p>并进一步由 Kubernetes 调度器将 Pod 绑定到目标节点</p>
</li>
<li><p>如果 DaemonSet 的 Pod 已经存在了 <code>nodeAffinity</code> 字段，该字段的值将被替换</p>
</li>
<li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nodeAffinity:</span></span><br><span class="line"><span class="attr">  requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">    nodeSelectorTerms:</span></span><br><span class="line"><span class="attr">    - matchFields:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">        operator:</span> <span class="string">In</span></span><br><span class="line"><span class="attr">        values:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">target-host-name</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>污点和容忍</p>
<ul>
<li><p>在调度 DaemonSet 的 Pod 时，污点和容忍（<a href="https://kuboard.cn/learning/k8s-intermediate/config/taints-toleration/" target="_blank" rel="noopener">taints and tolerations</a>）会被考量到，同时以下容忍（toleration）将被自动添加到 DaemonSet 的 Pod 中</p>
</li>
<li><table>
<thead>
<tr>
<th>Toleration Key</th>
<th>Effect</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>node.kubernetes.io/not-ready</td>
<td>NoExecute</td>
<td>节点未就绪。对应着 NodeCondition <code>Ready</code> 为 <code>False</code> 的情况</td>
</tr>
<tr>
<td>node.kubernetes.io/unreachable</td>
<td>NoExecute</td>
<td>节点不可触达。对应着 NodeCondition <code>Ready</code> 为 <code>Unknown</code> 的情况</td>
</tr>
<tr>
<td>node.kubernetes.io/disk-pressure</td>
<td>NoSchedule</td>
<td>节点磁盘吃紧</td>
</tr>
<tr>
<td>node.kubernetes.io/memory-pressure</td>
<td>NoSchedule</td>
<td>节点内存吃紧</td>
</tr>
<tr>
<td>node.kubernetes.io/unschedulable</td>
<td>NoSchedule</td>
<td>节点不可调度</td>
</tr>
<tr>
<td>node.kubernetes.io/network-unavailable</td>
<td>NoSchedule</td>
<td>节点网络不可用, 只对 host network 生效</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="通信模式"><a href="#通信模式" class="headerlink" title="通信模式"></a>通信模式</h5><ul>
<li><strong>Push：</strong> DaemonSet 容器组用来向另一个服务推送信息，例如数据库的统计信息<ul>
<li>这种情况下 DaemonSet 容器组没有客户端</li>
</ul>
</li>
<li><strong>NodeIP + Port：</strong> DaemonSet 容器组可以使用 <code>hostPort</code>，此时可通过节点的 IP 地址直接访问该容器组<ul>
<li>客户端需要知道节点的 IP 地址，以及 DaemonSet 容器组的 端口号</li>
</ul>
</li>
<li><strong>DNS：</strong> 创建一个 <a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener">Headless Service</a>，且该 Service 与 DaemonSet 有相同的 Pod Selector<ul>
<li>此时客户端可通过该 Service 的 DNS 解析到 DaemonSet 的 IP 地址</li>
</ul>
</li>
<li><strong>Service：</strong> 创建一个 Service，且该 Service 与 DaemonSet 有相同的 Pod Selector，客户端通过该 Service，可随机访问到某一个节点上的 DaemonSet 容器组</li>
</ul>
<h5 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h5><ul>
<li>如果节点的标签被修改，DaemonSet 将立刻向新匹配上的节点添加 Pod， 同时删除不匹配的节点上的 Pod</li>
<li>可以修改 DaemonSet 生成的 Pod,  只允许修改部分字段，但是 DaemonSet 控制器在创建新的 Pod 时，仍然会使用原有的 Template 进行 Pod 创建</li>
<li>可以删除 DaemonSet<ul>
<li>如果在 <code>kubectl</code> 命令中指定 <code>--cascade=false</code> 选项，DaemonSet 容器组将不会被删除</li>
<li>紧接着如果创建一个新的 DaemonSet，与之前删除的 DaemonSet 有相同的 <code>.spec.selector</code>，新建 DaemonSet 将直接把这些未删除的 Pod 纳入管理</li>
<li>DaemonSet 根据其 <code>updateStrategy</code> 决定是否更新这些 Pod</li>
</ul>
</li>
<li>可以对 DaemonSet 执行滚动更新操作</li>
</ul>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><ul>
<li>Kubernetes中的 Job 对象将创建一个或多个 Pod，并确保指定数量的 Pod 可以成功执行到进程正常结束：<ul>
<li>当 Job 创建的 Pod 执行成功并正常结束时，Job 将记录成功结束的 Pod 数量</li>
<li>当成功结束的 Pod 达到指定的数量时，Job 将完成执行</li>
<li>删除 Job 对象时，将清理掉由 Job 创建的 Pod</li>
</ul>
</li>
</ul>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">perl</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["perl",</span>  <span class="string">"-Mbignum=bpi"</span><span class="string">,</span> <span class="string">"-wle"</span><span class="string">,</span> <span class="string">"print bpi(2000)"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">  backoffLimit:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.spec.template</code> 是必填字段</p>
<ul>
<li>与 Pod 有相同的字段内容，但由于是内嵌元素，pod template 不包括阿 <code>apiVersion</code> 字段和 <code>kind</code> 字段</li>
<li>除了 Pod 所需的必填字段之外，Job 中的 pod template 必须指定<ul>
<li>合适的标签 <code>.spec.template.spec.labels</code></li>
<li>指定重启策略 <code>.spec.template.spec.restartPolicy</code>，此处只允许使用 <code>Never</code> 和 <code>OnFailure</code> 两个取值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="处理-Pod-和容器的失败"><a href="#处理-Pod-和容器的失败" class="headerlink" title="处理 Pod 和容器的失败"></a>处理 Pod 和容器的失败</h5><ul>
<li><p>Pod 中的容器可能会因为多种原因执行失败，例如：</p>
<ul>
<li>容器中的进程退出了，且退出码（exit code）不为 0</li>
<li>容器因为超出内存限制而被 Kill</li>
<li>其他原因</li>
</ul>
</li>
<li><p>整个 Pod 也可能因为多种原因执行失败，例如：</p>
<ul>
<li>Pod 从节点上被驱逐（节点升级、重启、被删除等）</li>
<li>Pod 的容器执行失败，且 <code>.spec.template.spec.restartPolicy = &quot;Never&quot;</code></li>
</ul>
</li>
<li><p>即使指定 <code>.spec.parallelism = 1</code>、 <code>.spec.completions = 1</code> 以及 <code>.spec.template.spec.restartPolicy = &quot;Never&quot;</code>，同一个应用程序仍然可能被启动多次</p>
<ul>
<li>如果指定 <code>.spec.parallelism</code> 和 <code>.spec.completions</code> 的值都大于 1，则，将可能有多个 Pod 同时执行<ul>
<li>此时 Pod 还必须能够处理并发的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>若期望在 Job 多次重试仍然失败的情况下停止该 Job</p>
<ul>
<li>可通过 <code>.spec.backoffLimit</code> 来设定 Job 最大的重试次数</li>
<li>该字段的默认值为 6</li>
</ul>
</li>
<li><p>Job 中的 Pod 执行失败之后，Job 控制器将按照一个指数增大的时间延迟（10s,20s,40s … 最大为 6 分钟）来多次重新创建 Pod</p>
<ul>
<li>如果没有新的 Pod 执行失败，则重试次数的计数将被重置</li>
</ul>
</li>
<li><p>建议在 debug 时，设置 <code>restartPolicy = &quot;Never&quot;</code>，或者使用日志系统确保失败的 Job 的日志不会丢失</p>
</li>
</ul>
<h5 id="终止和清理"><a href="#终止和清理" class="headerlink" title="终止和清理"></a>终止和清理</h5><ul>
<li>当 Job 完成后：<ul>
<li>将不会创建新的 Pod</li>
<li>已经创建 Job 和其 Pod 不会被清理掉<ul>
<li>可以继续查看已结束 Pod 的日志，以检查 errors/warnings 或者其他诊断用的日志输出</li>
</ul>
</li>
<li>可通过 <code>kubectl delete</code> 命令删除 Job</li>
</ul>
</li>
<li><code>.spec.activeDeadlineSeconds</code> 字段限定了 Job 对象在集群中的存活时长<ul>
<li>一旦达到 <code>.spec.activeDeadlineSeconds</code> 指定的时长，该 Job 创建的所有的 Pod 都将被终止，Job 的 Status 将变为 <code>type:Failed</code> 、 <code>reason: DeadlineExceeded</code></li>
<li>优先级高于 <code>.spec.backoffLimit</code><ul>
<li>正在重试失败 Pod 的 Job，在达到 <code>.spec.activeDeadlineSecondes</code> 时，将立刻停止重试，即使 <code>.spec.backoffLimit</code> 还未达到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="自动清理"><a href="#自动清理" class="headerlink" title="自动清理"></a>自动清理</h5><ul>
<li><p>CronJob 可以根据其中定义的基于容量的清理策略（capacity-based cleanup policy）自动清理 Job</p>
</li>
<li><p>TTL 机制是另外一种自动清理已结束 Job（<code>Completed</code> 或 <code>Finished</code>）的方式：</p>
<ul>
<li>TTL 机制由 TTL 控制器提供</li>
<li>在 Job 对象中指定 <code>.spec.ttlSecondsAfterFinished</code> 字段可激活该特性</li>
<li>当 TTL 控制器清理 Job 时，TTL 控制器将删除 Job 对象，以及由该 Job 创建的所有 Pod 对象</li>
</ul>
</li>
<li><p>删除 Job 时，其生命周期函数将被触发，例如 finalizer</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pi-with-ttl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">perl</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["perl",</span>  <span class="string">"-Mbignum=bpi"</span><span class="string">,</span> <span class="string">"-wle"</span><span class="string">,</span> <span class="string">"print bpi(2000)"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Job <code>pi-with-ttl</code> 的 <code>ttlSecondsAfterFinished</code> 值为 100，则在其结束 <code>100</code> 秒之后，将可以被自动删除</li>
<li>如果 <code>ttlSecondsAfterFinished</code> 被设置为 <code>0</code>，则 TTL 控制器在 Job 执行结束后，立刻就可以清理该 Job 及其 Pod</li>
<li>如果 <code>ttlSecondsAfterFinished</code> 值未设置，则 TTL 控制器不会清理该 Job</li>
</ul>
<h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><ul>
<li><p>CronJob 按照预定的时间计划（schedule）创建 Job</p>
</li>
<li><p>所有 CronJob 的 <code>schedule</code> 中所定义的时间，都是基于 master 所在时区来进行计算的</p>
</li>
<li><p>CronJob 在时间计划中的每次执行时刻, 可能会创建不止一个 Job 对象, 所以需要保持 Job 的<strong>幂等性</strong></p>
</li>
</ul>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">"*/1 * * * *"</span></span><br><span class="line"><span class="attr">  jobTemplate:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">          containers:</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">            image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">            args:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/bin/sh</span></span><br><span class="line"><span class="bullet">            -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line"><span class="attr">          restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>所有对 CronJob 对象作出的修改，尤其是 <code>.spec</code> 的修改，都只对修改之后新建的 Job 有效，已经创建的 Job 不会受到影响</p>
</li>
<li><p><code>.spec.schedule</code> 必填字段</p>
<ul>
<li><p>类型为 <a href="https://en.wikipedia.org/wiki/Cron" target="_blank" rel="noopener">Cron</a> 格式的字符串，例如 <code>0 * * * *</code> 或者 <code>@hourly</code>，该字段定义了 CronJob 应该何时创建和执行 Job。</p>
</li>
<li><p>该字段同样支持  step 值（step values），参考 <a href="https://www.freebsd.org/cgi/man.cgi?crontab(5)" target="_blank" rel="noopener">FreeBSD manual</a></p>
<ul>
<li>例如，指定 CronJob 每隔两个小时执行一次，可以有如下三种写法：<ul>
<li><code>0 0,2,4,5,6,8,12,14,16,17,20,22 * * *</code></li>
<li>使用 范围值 + Step 值的写法：<code>0 0-23/2 * * *</code></li>
<li>Step 也可以跟在一个星号后面，如 <code>0 */2 * * *</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.spec.jobTemplate</code> 必填字段</p>
<ul>
<li>该字段的结构与 Job 相同，只是不需要 <code>apiVersion</code> 和 <code>kind</code></li>
</ul>
</li>
<li><p><code>.spec.startingDeadlineSeconds</code> 选填字段</p>
<ul>
<li>代表从计划的时间点开始，最迟多少秒之内必须启动 Job, 超过了这个时间点，CronJob 就不会为其创建 Job</li>
<li>CronJob 控制器将检查自上一次执行的时间点到现在为止有多少次执行被错过了<ul>
<li>如果错过的执行次数超过了 100，则 CronJob 控制器将不再创建 Job 对象</li>
<li>如果设置了 <code>startingDeadlineSeconds</code>, 则按照从 <code>startingDeadlineSeconds</code> 秒之前到现在为止的时间段计算被错过的执行次数<ul>
<li>例如被设置为 <code>200</code>，则控制器将计算过去 200 秒内，被错过的执行次数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.spec.concurrencyPolicy</code>  选填字段</p>
<ul>
<li>指定了如何控制该 CronJob 创建的 Job 的并发性，可选的值有：<ul>
<li><code>Allow</code>： 默认值，允许并发运行 Job</li>
<li><code>Forbid</code>： 不允许并发运行 Job<ul>
<li>如果新的执行时间点到了，而上一个 Job 还未执行完，则 CronJob 将跳过新的执行时间点，保留仍在运行的 Job，且不会在此刻创建新的 Job</li>
</ul>
</li>
<li><code>Replace</code>： 如果新的执行时间点到了，而上一个 Job 还未执行完，则 CronJob 将创建一个新的 Job 以替代正在执行的 Job</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.spec.suspend</code> 选填字段</p>
<ul>
<li>如果该字段设置为 <code>true</code>，所有的后续执行都将挂起，该字段不会影响到已经创建的 Job</li>
<li>默认值为 <code>false</code></li>
<li>挂起（suspend）的时间段内，如果恰好存在有计划的执行时间点，则这些执行时间计划都被记录下来<ul>
<li>如果不指定 <code>.spec.startingDeadlineSeconds</code>，并将 <code>.spec.suspend</code> 字段从 <code>true</code> 修改为 <code>false</code>，则挂起这段时间内的执行计划都将被立刻执行</li>
</ul>
</li>
</ul>
</li>
<li><p><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code> 字段是可选的</p>
<ul>
<li><p>这些字段指定了 CronJob 应该保留多少个 completed 和 failed 的 Job 记录</p>
</li>
<li><p><code>.spec.successfulJobsHistoryLimit</code> 的默认值为 3</p>
</li>
<li><p><code>.spec.failedJobsHistoryLimit</code> 的默认值为 1</p>
</li>
<li><p>如果将其设置为 <code>0</code>，则 CronJob 不会保留已经结束的 Job 的记录</p>
</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul>
<li>Kubernetes garbage collector（垃圾回收器）的作用是删除那些曾经有 owner，后来又不再有 owner 的对象</li>
</ul>
<h5 id="所有者和从属对象"><a href="#所有者和从属对象" class="headerlink" title="所有者和从属对象"></a>所有者和从属对象</h5><ul>
<li>每一个从属对象都有一个 <code>metadata.ownerReferences</code> 字段，标识其拥有者是哪一个对象</li>
<li>对于 ReplicationController、ReplicaSet、StatefulSet、DaemonSet、Deployment、Job、CronJob等创建或管理的对象，Kubernetes 都将自动为其设置 <code>ownerReference</code> 的值</li>
<li>跨名称空间的所有者-从属对象的关系是不被允许的<ul>
<li>名称空间内的从属对象只能指定同名称空间的对象作为其所有者</li>
<li>集群级别的对象只能指定集群级别的对象作为其所有者</li>
</ul>
</li>
</ul>
<h5 id="垃圾收集器如何删除从属对象"><a href="#垃圾收集器如何删除从属对象" class="headerlink" title="垃圾收集器如何删除从属对象"></a>垃圾收集器如何删除从属对象</h5><ul>
<li>当删除某个对象时，可以指定该对象的从属对象是否同时被自动删除，这种操作叫做级联删除（cascading deletion）<ul>
<li>级联删除有两种模式：后台（background）和前台（foreground）</li>
</ul>
</li>
<li>如果删除对象时不删除自动删除其从属对象，此时从属对象被认为是孤儿（或孤立的 orphaned）</li>
</ul>
<h5 id="Foreground-级联删除"><a href="#Foreground-级联删除" class="headerlink" title="Foreground 级联删除"></a>Foreground 级联删除</h5><ul>
<li>根对象（直接被删除的对象）先进入“正在删除”（deletion in progress）状态，此时：<ul>
<li>对象仍然可以通过 REST API 查询到</li>
<li>对象的 <code>deletionTimestamp</code> 字段被设置</li>
<li>对象的 <code>metadata.finalizers</code> 包含值 <code>foregroundDeletion</code></li>
</ul>
</li>
<li>一旦对象被设置为 “deletion in progress” 状态，垃圾回收器将删除其从属对象<ul>
<li>当垃圾回收器已经删除了所有的 “blocking” 从属对象（<code>ownerReference.blockOwnerDeletion=true</code> 的对象）以后，将删除所有者对象</li>
</ul>
</li>
<li>在 “foregroundDeletion” 模式下，只有 <code>ownerReference.blockOwnerDeletion=true</code> 的对象将阻止所有者对象的删除<ul>
<li>在 Kubernetes 版本 1.7 开始，增加了 <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement" target="_blank" rel="noopener">admission controller</a> ，可以基于所有者对象的删除权限配置限制用户是否可以设置 <code>blockOwnerDeletion</code> 字段为 true，因此未经授权的从属对象将不能阻止所有者对象的删除</li>
</ul>
</li>
<li>如果对象的 <code>ownerReferences</code> 字段由控制器自动设置（例如，Deployment、ReplicaSet），<code>blockOwnerDeletion</code> 也将被自动设置，无需手工修改该字段的取值</li>
</ul>
<h5 id="Background-级联删除"><a href="#Background-级联删除" class="headerlink" title="Background 级联删除"></a>Background 级联删除</h5><ul>
<li>将立刻删除所有者对象，并由垃圾回收器在后台删除其从属对象</li>
</ul>
<h5 id="设置级联删除策略"><a href="#设置级联删除策略" class="headerlink" title="设置级联删除策略"></a>设置级联删除策略</h5><ul>
<li>在删除对象时，通过参数 <code>deleteOptions</code> 的 <code>propagationPolicy</code> 字段，可以设置级联删除的策略。可选的值有： <code>Orphan</code>、<code>Foreground</code>、<code>Background</code></li>
<li>默认值：<ul>
<li>在 Kubernetes 1.9 之前，许多类型控制器的默认垃圾回收策略都是 <code>orphan</code>，例如，ReplicationController、ReplicaSet、StatefulSet、DaemonSet、Deployment</li>
<li>对于 apiVersion 为 <code>extensions/v1beta1</code>、<code>apps/v1beta1</code>、和 <code>apps/v1beta2</code> 的对象，除非特殊指定，垃圾回收策略默认为 <code>orphan</code></li>
<li>在 Kubernetes 1.9 中，对于所有 apiVersion 为 <code>apps/v1</code> 的对象，从属对象默认都将被删除</li>
</ul>
</li>
</ul>
<h2 id="服务与网络"><a href="#服务与网络" class="headerlink" title="服务与网络"></a>服务与网络</h2><h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><ul>
<li>Service 是 Kubernetes 中的一种服务发现机制：<ul>
<li>Pod 有自己的 IP 地址</li>
<li>Service 被赋予一个唯一的 dns name</li>
<li>Service 通过 label selector 选定一组 Pod</li>
<li>Service 实现负载均衡，可将请求均衡分发到选定这一组 Pod 中</li>
</ul>
</li>
<li>使用 Kubernetes 的最佳实践：<ul>
<li>Service 与 Controller 同名</li>
<li>Service 与 Controller 使用相同的 label selector</li>
</ul>
</li>
<li>Service 从自己的 IP 地址和 <code>port</code> 端口接收请求，并将请求映射到符合条件的 Pod 的 <code>targetPort</code></li>
<li>相关 IP 概念<ul>
<li>Node IP<ul>
<li>集群中节点的物理网卡 <code>IP</code> 地址 (一般为内网)</li>
</ul>
</li>
<li>Pod IP<ul>
<li>每个 <code>Pod</code> 的 <code>IP</code> 地址，是 <code>Docker Engine</code> 根据 <code>docker0</code> 网桥的 <code>IP</code> 地址段进行分配的</li>
</ul>
</li>
<li>Cluster IP<ul>
<li>虚拟的 <code>IP</code>，由 K8s 自己来进行管理和分配地址</li>
<li>仅仅作用于 <code>Kubernetes Service</code> 这个对象</li>
<li>只能结合 <code>Service Port</code> 来组成一个可以通信的服务</li>
</ul>
</li>
</ul>
</li>
<li>类型<ul>
<li>ClusterIP<ul>
<li>默认 type</li>
<li>在群集中的内部 IP 上公布服务，只在集群内部可以访问到</li>
</ul>
</li>
<li>NodePort<ul>
<li>使用 NAT 在集群中每个的同一端口上公布服务</li>
<li>可以通过访问集群中任意节点 + 端口号的方式访问服务 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code></li>
<li>此时 ClusterIP 的访问方式仍然可用</li>
</ul>
</li>
<li>LoadBalancer<ul>
<li>在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址</li>
<li>此时 ClusterIP 和 NodePort 的访问方式仍然可用</li>
</ul>
</li>
<li>ExternalName<ul>
<li>通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容</li>
</ul>
</li>
</ul>
</li>
<li>使用<ul>
<li>Pod 中可以直接访问 Service 名字</li>
</ul>
</li>
</ul>
<h4 id="创建-Service"><a href="#创建-Service" class="headerlink" title="创建 Service"></a>创建 Service</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">9377</span></span><br></pre></td></tr></table></figure>

<ul>
<li>端口的名字只能包含小写字母、数字、<code>-</code>，并且必须以数字或字母作为开头及结尾</li>
<li>Service 中额外字段的作用：<ul>
<li><code>service.spec.sessionAffinity</code><ul>
<li>默认值为 “None”</li>
<li>如果设定为 “ClientIP”，则同一个客户端的连接将始终被转发到同一个 Pod</li>
</ul>
</li>
<li><code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code><ul>
<li>默认值为 10800 （3 小时）</li>
<li>设定会话保持的持续时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="无-label-selector"><a href="#无-label-selector" class="headerlink" title="无 label selector"></a>无 label selector</h5><ul>
<li>Service 通常用于提供对 Kubernetes Pod 的访问，但也可以将其用于任何其他形式的后端。例如：<ul>
<li>在生产环境中使用一个 Kubernetes 外部的数据库集群，在测试环境中使用 Kubernetes 内部的数据库</li>
<li>将 Service 指向另一个名称空间中的 Service，或者另一个 Kubernetes 集群中的 Service</li>
<li>正在将程序迁移到 Kubernetes，但是只将一部分后端程序运行在 Kubernetes 中</li>
</ul>
</li>
<li>因为 Service 没有 selector，相应的 Endpoint 对象就无法自动创建<ul>
<li>可以手动创建一个 Endpoint 对象，以便将该 Service 映射到后端服务真实的 IP 地址和端口</li>
<li>Endpoint 中的 IP 地址不可以是 loopback（127.0.0.0/8 IPv4 或 ::1/128 IPv6），或 link-local（169.254.0.0/16 IPv4、224.0.0.0/24 IPv4 或 fe80::/64 IPv6）</li>
<li>Endpoint 中的 IP 地址不可以是集群中其他 Service 的 ClusterIP</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">9376</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="attr">  - addresses:</span></span><br><span class="line"><span class="attr">      - ip:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.42</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">      - port:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure>

<h4 id="虚拟-IP-和服务代理"><a href="#虚拟-IP-和服务代理" class="headerlink" title="虚拟 IP 和服务代理"></a>虚拟 IP 和服务代理</h4><ul>
<li>Kubernetes 集群中的每个节点都运行了一个 <code>kube-proxy</code>，负责为 Service（ExternalName 类型的除外）提供虚拟 IP 访问</li>
<li>使用 proxy 的原因大致有如下几个：<ul>
<li>DNS 不确保严格检查 TTL（Time to live），并且在缓存的 dns 解析结果应该过期以后，仍然继续使用缓存中的记录</li>
<li>某些应用程序只做一次 DNS 解析，并一直使用缓存下来的解析结果</li>
<li>即使应用程序对 DNS 解析做了合适的处理，为 DNS 记录设置过短（或者 0）的 TTL 值，将给 DNS 服务器带来过大的负载</li>
</ul>
</li>
</ul>
<h5 id="User-space-代理模式"><a href="#User-space-代理模式" class="headerlink" title="User space 代理模式"></a>User space 代理模式</h5><p><img src="https://gitee.com/chansonchan/image/raw/master/uPic/services-userspace-overview.7dfebdc9.svg" alt="Kubernetes教程：Service user space"></p>
<ul>
<li>kube-proxy 监听 kubernetes master 以获得添加和移除 Service / Endpoint 的事件</li>
<li>kube-proxy 在其所在的节点（每个节点都有 kube-proxy）上为每一个 Service 打开一个随机端口</li>
<li>kube-proxy 安装 iptables 规则，将发送到该 Service 的 ClusterIP（虚拟 IP）/ Port 的请求重定向到该随机端口</li>
<li>任何发送到该随机端口的请求将被代理转发到该 Service 的后端 Pod 上（kube-proxy 从 Endpoint 信息中获得可用 Pod）</li>
<li>kube-proxy 在决定将请求转发到后端哪一个 Pod 时，默认使用 round-robin（轮询）算法，并会考虑到 Service 中的 <code>SessionAffinity</code> 的设定</li>
</ul>
<h5 id="Iptables-代理模式-默认模式"><a href="#Iptables-代理模式-默认模式" class="headerlink" title="Iptables 代理模式 (默认模式)"></a>Iptables 代理模式 (默认模式)</h5><p><img src="https://gitee.com/chansonchan/image/raw/master/uPic/services-iptables-overview.fc39e9e4.svg" alt="Kubernetes教程：Service iptables proxy"></p>
<ul>
<li><p>kube-proxy 监听 kubernetes master 以获得添加和移除 Service / Endpoint 的事件</p>
</li>
<li><p>kube-proxy 在其所在的节点（每个节点都有 kube-proxy）上为每一个 Service 安装 iptable 规则</p>
</li>
<li><p>iptables 将发送到 Service 的 ClusterIP / Port 的请求重定向到 Service 的后端 Pod 上</p>
<ul>
<li>对于 Service 中的每一个 Endpoint，kube-proxy 安装一个 iptable 规则</li>
<li>默认情况下，kube-proxy 随机选择一个 Service 的后端 Pod</li>
</ul>
</li>
<li><p>优点:</p>
<ul>
<li>更低的系统开销：在 linux netfilter 处理请求，无需在 user space 和 kernel space 之间切换</li>
<li>更稳定</li>
</ul>
</li>
<li><p>与 user space mode 的差异：</p>
<ul>
<li><p>使用 iptables mode 时，如果第一个 Pod 没有响应，则创建连接失败</p>
</li>
<li><p>使用 user space mode 时，如果第一个 Pod 没有响应，kube-proxy 会自动尝试连接另外一个后端 Pod</p>
</li>
<li><p>可以配置 Pod 就绪检查（readiness probe）确保后端 Pod 正常工作，此时在 iptables 模式下 kube-proxy 将只使用健康的后端 Pod，从而避免了 kube-proxy 将请求转发到已经存在问题的 Pod 上</p>
</li>
</ul>
</li>
</ul>
<h5 id="IPVS-代理模式"><a href="#IPVS-代理模式" class="headerlink" title="IPVS 代理模式"></a>IPVS 代理模式</h5><p><img src="https://gitee.com/chansonchan/image/raw/master/uPic/services-ipvs-overview.25df78cc.svg" alt="Kubernetes教程：Service IPVS proxy"></p>
<ul>
<li><p>kube-proxy 监听 kubernetes master 以获得添加和移除 Service / Endpoint 的事件</p>
</li>
<li><p>kube-proxy 根据监听到的事件，调用 netlink 接口，创建 IPVS 规则；并且将 Service/Endpoint 的变化同步到 IPVS 规则中</p>
</li>
<li><p>当访问一个 Service 时，IPVS 将请求重定向到后端 Pod</p>
</li>
<li><p>优点:</p>
<ul>
<li>基于 netfilter 的 hook 功能，与 iptables 代理模式相似，但是 IPVS 代理模式使用 hash table 作为底层的数据结构，并在 kernel space 运作。这就意味着<ul>
<li>IPVS 代理模式可以比 iptables 代理模式有更低的网络延迟，在同步代理规则时，也有更高的效率</li>
<li>与 user space 代理模式 / iptables 代理模式相比，IPVS 模式可以支持更大的网络流量</li>
</ul>
</li>
</ul>
</li>
<li><p>提供更多的负载均衡选项：</p>
<ul>
<li>rr: round-robin</li>
<li>lc: least connection (最小打开的连接数)</li>
<li>dh: destination hashing</li>
<li>sh: source hashing</li>
<li>sed: shortest expected delay</li>
<li>nq: never queue</li>
</ul>
</li>
<li><p>如果要使用 IPVS 模式，您必须在启动 kube-proxy 前为节点的 linux 启用 IPVS</p>
</li>
<li><p>kube-proxy 以 IPVS 模式启动时，如果发现节点的 linux 未启用 IPVS，则退回到 iptables 模式</p>
</li>
</ul>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><ul>
<li>kubelet 查找有效的 Service，并针对每一个 Service，向其所在节点上的 Pod 注入一组环境变量。支持的环境变量有：<ul>
<li><a href="https://docs.docker.com/network/links/" target="_blank" rel="noopener">Docker links 兼容</a> 的环境变量</li>
<li>{SVCNAME}_SERVICE_HOST 和 {SVCNAME}_SERVICE_PORT<ul>
<li>Service name 被转换为大写</li>
<li>小数点 <code>.</code> 被转换为下划线 <code>_</code></li>
</ul>
</li>
</ul>
</li>
<li>如果要在 Pod 中使用基于环境变量的服务发现方式，必须先创建 Service，再创建调用 Service 的 Pod<ul>
<li>否则 Pod 中不会有该 Service 对应的环境变量</li>
</ul>
</li>
</ul>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><ul>
<li><p>CoreDNS 监听 Kubernetes API 上创建和删除 Service 的事件，并为每一个 Service 创建一条 DNS 记录</p>
<ul>
<li>集群中所有的 Pod 都可以使用 DNS Name 解析到 Service 的 IP 地址</li>
</ul>
</li>
<li><p>例如名称空间 <code>my-ns</code> 中的 Service <code>my-service</code>，将对应一条 DNS 记录 <code>my-service.my-ns</code></p>
<ul>
<li>名称空间 <code>my-ns</code> 中的 Pod 可以直接 <code>nslookup my-service</code> （<code>my-service.my-ns</code> 也可以）</li>
<li>其他名称空间的 Pod 必须使用 <code>my-service.my-ns</code></li>
<li><code>my-service</code> 和 <code>my-service.my-ns</code> 都将被解析到 Service 的 Cluster IP</li>
</ul>
</li>
<li><p>同样支持 DNS SRV（Service）记录，用于查找一个命名的端口</p>
<ul>
<li>假设 <code>my-service.my-ns</code> Service 有一个 TCP 端口名为 <code>http</code>，则可以 <code>nslookup _http._tcp.my-service.my-ns</code> 以发现该Service 的 IP 地址及端口 <code>http</code></li>
</ul>
</li>
<li><p>对于 <code>ExternalName</code> 类型的 Service，只能通过 DNS 的方式进行服务发现</p>
</li>
</ul>
<h5 id="Headless-Services"><a href="#Headless-Services" class="headerlink" title="Headless Services"></a>Headless Services</h5><ul>
<li>“Headless” Service 不提供负载均衡的特性，也没有自己的 IP 地址<ul>
<li>创建 “headless” Service 时，只需要指定 <code>.spec.clusterIP</code> 为 “None”。</li>
</ul>
</li>
<li>“Headless” Service 可以用于对接其他形式的服务发现机制，而无需与 Kubernetes 的实现绑定</li>
<li>对于 “Headless” Service 而言：<ul>
<li>没有 Cluster IP</li>
<li>kube-proxy 不处理这类 Service</li>
<li>Kubernetes 不提供负载均衡或代理支持</li>
</ul>
</li>
<li>DNS 的配置方式取决于该 Service 是否配置了 selector：<ul>
<li>配置了 Selector<ul>
<li>Endpoints Controller 创建 <code>Endpoints</code> 记录，并修改 DNS 配置，使其直接返回指向 selector 选取的 Pod 的 IP 地址</li>
</ul>
</li>
<li>没有配置 Selector<ul>
<li>Endpoints Controller 不创建 <code>Endpoints</code> 记录。DNS服务返回如下结果中的一种：<ul>
<li>对 ExternalName 类型的 Service，返回 CNAME 记录</li>
<li>对于其他类型的 Service，返回与 Service 同名的 <code>Endpoints</code> 的 A 记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚拟-IP-的实现"><a href="#虚拟-IP-的实现" class="headerlink" title="虚拟 IP 的实现"></a>虚拟 IP 的实现</h4><h5 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h5><ul>
<li><p>Kubernetes 的一个设计哲学是：尽量避免非人为错误产生的可能性</p>
<ul>
<li>就设计 Service 而言，Kubernetes 应该将选择的端口号与其他人选择的端口号隔离开</li>
<li>为此 Kubernetes 为每一个 Service 分配一个该 Service 专属的 IP 地址</li>
</ul>
</li>
<li><p>为了确保每个 Service 都有一个唯一的 IP 地址，Kubernetes 在创建 Service 之前，先更新 etcd 中的一个全局分配表，如果更新失败（例如 IP 地址已被其他 Service 占用），则 Service 不能成功创建</p>
</li>
<li><p>Kubernetes 使用一个后台控制器检查该全局分配表中的 IP 地址的分配是否仍然有效，并且自动清理不再被 Service 使用的 IP 地址</p>
</li>
</ul>
<h5 id="Service-的-IP-地址"><a href="#Service-的-IP-地址" class="headerlink" title="Service 的 IP 地址"></a>Service 的 IP 地址</h5><ul>
<li>Pod 的 IP 地址路由到一个确定的目标，然而 Service 的 IP 地址则不同，通常背后并不对应一个唯一的目标</li>
<li>kube-proxy 使用 iptables （Linux 中的报文处理逻辑）来定义虚拟 IP 地址</li>
<li>当客户端连接到该虚拟 IP 地址时，它们的网络请求将自动发送到一个合适的 Endpoint</li>
<li>Service 对应的环境变量和 DNS 实际上反应的是 Service 的虚拟 IP 地址（和端口）</li>
</ul>
<h5 id="Userspace"><a href="#Userspace" class="headerlink" title="Userspace"></a>Userspace</h5><ul>
<li><p>当后端 Service 被创建时，Kubernetes master 为其分配一个虚拟 IP 地址（假设是 10.0.0.1），并假设 Service 的端口是 1234</p>
</li>
<li><p>集群中所有的 kube-proxy 都实时监听着 Service 的创建和删除</p>
</li>
<li><p>Service 创建后，kube-proxy 将打开一个新的随机端口，并设定 iptables 的转发规则（以便将该 Service 虚拟 IP 的网络请求全都转发到这个新的随机端口上），并且 kube-proxy 将开始接受该端口上的连接</p>
</li>
<li><p>当一个客户端连接到该 Service 的虚拟 IP 地址时，iptables 的规则被触发，并且将网络报文重定向到 kube-proxy 自己的随机端口上</p>
</li>
<li><p>kube-proxy 接收到请求后，选择一个后端 Pod，再将请求以代理的形式转发到该后端 Pod</p>
</li>
<li><p>这意味着 Service 可以选择任意端口号，而无需担心端口冲突</p>
</li>
<li><p>客户端可以直接连接到一个 IP:port，无需关心最终在使用哪个 Pod 提供服务</p>
</li>
</ul>
<h5 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h5><ul>
<li><p>当后端 Service 被创建时，Kubernetes master 为其分配一个虚拟 IP 地址（假设是 10.0.0.1），并假设 Service 的端口是 1234</p>
</li>
<li><p>集群中所有的 kube-proxy 都实时监听者 Service 的创建和删除</p>
</li>
<li><p>Service 创建后，kube-proxy 设定了一系列的 iptables 规则（这些规则可将虚拟 IP 地址映射到 per-Service 的规则）</p>
</li>
<li><p>per-Service 规则进一步链接到 per-Endpoint 规则，并最终将网络请求重定向（使用 destination-NAT）到后端 Pod</p>
</li>
<li><p>当一个客户端连接到该 Service 的虚拟 IP 地址时，iptables 的规则被触发</p>
</li>
<li><p>一个后端 Pod 将被选中（基于 session affinity 或者随机选择），且网络报文被重定向到该后端 Pod</p>
</li>
<li><p>与 userspace proxy 不同，网络报文不再被复制到 userspace，kube-proxy 也无需处理这些报文，且报文被直接转发到后端 Pod。</p>
</li>
<li><p>在使用 node-port 或 load-balancer 类型的 Service 时，以上的代理处理过程是相同的</p>
</li>
</ul>
<h5 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h5><ul>
<li>在一个大型集群中（例如，存在 10000 个 Service）iptables 的操作将显著变慢</li>
<li>IPVS 的设计是基于 in-kernel hash table 执行负载均衡</li>
<li>因此使用 IPVS 的 kube-proxy 在 Service 数量较多的情况下仍然能够保持好的性能</li>
<li>同时基于 IPVS 的 kube-proxy 可以使用更复杂的负载均衡算法（最少连接数、基于地址的、基于权重的等）</li>
</ul>
<h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><ul>
<li><p>Opaque</p>
</li>
<li><p>kubernetes.io/dockerconfigjson</p>
</li>
<li><p>kubernetes.io/service-account-token</p>
</li>
<li><p>Horizontal Pod Autoscaling (HPA)</p>
<ul>
<li>Heapster</li>
</ul>
</li>
<li><p>Job</p>
<ul>
<li>CronJob</li>
</ul>
</li>
<li><p>RBAC</p>
<ul>
<li>Role 和 ClusterRole<ul>
<li>Rule</li>
</ul>
</li>
<li>Subject<ul>
<li>User Account</li>
<li>Group</li>
<li>Service Account</li>
</ul>
</li>
<li>RoleBinding 和 ClusterRoleBinding</li>
</ul>
</li>
<li><p>DaemonSet</p>
</li>
<li><p>StatefulSet</p>
<ul>
<li>服务的有状态和无状态</li>
</ul>
</li>
<li><p>持久化存储</p>
<ul>
<li>PV</li>
</ul>
</li>
<li><p>PVC</p>
<ul>
<li>StorageClass</li>
</ul>
</li>
</ul>
<h2 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h2><ul>
<li><p>内部服务发现</p>
<ul>
<li><p>通过 apiserver 查询</p>
<ul>
<li>依赖 K8s</li>
</ul>
</li>
</ul>
</li>
<li><p>通过环境变量</p>
<ul>
<li>依赖的服务必须在 Pod 启动之前就存在</li>
<li>DNS Server</li>
<li>kubedns<ul>
<li>coredns</li>
</ul>
</li>
</ul>
</li>
<li><p>外部服务发现</p>
<ul>
<li>ingress<ul>
<li>Traefik</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h2><ul>
<li>概念<ul>
<li>chart</li>
<li>config</li>
<li>release</li>
</ul>
</li>
<li>Helm Client</li>
<li>Tiller Server</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/k8s/" rel="tag"># k8s</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/17/Mysql-定时备份-(基于-Dokcer-运行)/" rel="next" title="Mysql 定时备份 (基于 Dokcer 运行)">
                <i class="fa fa-chevron-left"></i> Mysql 定时备份 (基于 Dokcer 运行)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/26/人月神话笔记/" rel="prev" title="人月神话笔记">
                人月神话笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
        <div id="gitment-container"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Chaosn Chan">
            
              <p class="site-author-name" itemprop="name">Chaosn Chan</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/chenchensheng" title="GitHub &rarr; https://github.com/chenchensheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:330266801@qq.com" title="E-Mail &rarr; mailto:330266801@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-基础"><span class="nav-number">1.</span> <span class="nav-text">Docker 基础</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#K8s-基础"><span class="nav-number">2.</span> <span class="nav-text">K8s 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组件"><span class="nav-number">2.1.</span> <span class="nav-text">组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构"><span class="nav-number">2.2.</span> <span class="nav-text">架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#节点"><span class="nav-number">2.2.1.</span> <span class="nav-text">节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#节点状态"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">节点状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Addresses"><span class="nav-number">2.2.1.1.1.</span> <span class="nav-text">Addresses</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Conditions"><span class="nav-number">2.2.1.1.2.</span> <span class="nav-text">Conditions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Capacity-and-Allocatable"><span class="nav-number">2.2.1.1.3.</span> <span class="nav-text">Capacity and Allocatable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Info"><span class="nav-number">2.2.1.1.4.</span> <span class="nav-text">Info</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点管理"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">节点管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#节点控制器"><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">节点控制器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#节点自注册"><span class="nav-number">2.2.1.2.2.</span> <span class="nav-text">节点自注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#手动管理节点"><span class="nav-number">2.2.1.2.3.</span> <span class="nav-text">手动管理节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#节点容量"><span class="nav-number">2.2.1.2.4.</span> <span class="nav-text">节点容量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群内的通信"><span class="nav-number">2.2.2.</span> <span class="nav-text">集群内的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cluster-to-Master"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">Cluster to Master</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Master-to-Cluster"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">Master to Cluster</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#apiserver-to-kubelet"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">apiserver to kubelet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#apiserver-to-nodes-pods-services"><span class="nav-number">2.2.2.2.2.</span> <span class="nav-text">apiserver to nodes, pods, services</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制器"><span class="nav-number">2.2.3.</span> <span class="nav-text">控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制器模式"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">控制器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#通过-APIServer-进行控制"><span class="nav-number">2.2.3.1.1.</span> <span class="nav-text">通过 APIServer 进行控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#直接控制"><span class="nav-number">2.2.3.1.2.</span> <span class="nav-text">直接控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目标状态-vs-当前状态"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">目标状态 vs 当前状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设计"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行控制器的方式"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">运行控制器的方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作-Kubernetes"><span class="nav-number">2.3.</span> <span class="nav-text">操作 Kubernetes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes-对象"><span class="nav-number">2.3.1.</span> <span class="nav-text">Kubernetes 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的-spec-和-status"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">对象的 spec 和 status</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#描述-Kubernetes-对象"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">描述 Kubernetes 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理-Kubernetes-对象"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">管理 Kubernetes 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#指令性的命令行"><span class="nav-number">2.3.1.3.1.</span> <span class="nav-text">指令性的命令行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指令性的对象配置"><span class="nav-number">2.3.1.3.2.</span> <span class="nav-text">指令性的对象配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#声明式的对象配置"><span class="nav-number">2.3.1.3.3.</span> <span class="nav-text">声明式的对象配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名称"><span class="nav-number">2.3.2.</span> <span class="nav-text">名称</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Names"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">Names</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS-Subdomain-Names"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">DNS Subdomain Names</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS-Label-Names"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">DNS Label Names</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Path-Segment-Names"><span class="nav-number">2.3.2.1.3.</span> <span class="nav-text">Path Segment Names</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UIDs"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">UIDs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名称空间"><span class="nav-number">2.3.3.</span> <span class="nav-text">名称空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#名称空间与-DNS"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">名称空间与 DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用名称空间共享集群"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">使用名称空间共享集群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查看名称空间"><span class="nav-number">2.3.3.2.1.</span> <span class="nav-text">查看名称空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看概要信息"><span class="nav-number">2.3.3.2.2.</span> <span class="nav-text">查看概要信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建名称空间"><span class="nav-number">2.3.3.2.3.</span> <span class="nav-text">创建名称空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除名称空间"><span class="nav-number">2.3.3.2.4.</span> <span class="nav-text">删除名称空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标签和选择器"><span class="nav-number">2.3.4.</span> <span class="nav-text">标签和选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#句法和字符集"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">句法和字符集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标签选择器"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">标签选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基于等式的选择方式"><span class="nav-number">2.3.4.2.1.</span> <span class="nav-text">基于等式的选择方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于集合的选择方式"><span class="nav-number">2.3.4.2.2.</span> <span class="nav-text">基于集合的选择方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查询条件"><span class="nav-number">2.3.4.3.1.</span> <span class="nav-text">查询条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes-对象引用"><span class="nav-number">2.3.4.3.2.</span> <span class="nav-text">Kubernetes 对象引用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Service"><span class="nav-number">2.3.4.3.2.1.</span> <span class="nav-text">Service</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#有些对象支持基于集合的选择方式"><span class="nav-number">2.3.4.3.2.2.</span> <span class="nav-text">有些对象支持基于集合的选择方式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解"><span class="nav-number">2.3.5.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段选择器"><span class="nav-number">2.3.6.</span> <span class="nav-text">字段选择器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">2.4.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#更新镜像"><span class="nav-number">2.4.1.</span> <span class="nav-text">更新镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器的环境变量"><span class="nav-number">2.4.2.</span> <span class="nav-text">容器的环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime-Class"><span class="nav-number">2.4.3.</span> <span class="nav-text">Runtime Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器的生命周期-容器钩子"><span class="nav-number">2.4.4.</span> <span class="nav-text">容器的生命周期 - 容器钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hook-handler-的实现"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">hook handler 的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hook-handler-的执行"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">hook handler 的执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hook-触发的保证"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">hook 触发的保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试-hook-handler"><span class="nav-number">2.4.4.4.</span> <span class="nav-text">调试 hook handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-postStart-和-preStop-处理程序"><span class="nav-number">2.4.4.5.</span> <span class="nav-text">定义 postStart 和 preStop 处理程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作负载"><span class="nav-number">2.5.</span> <span class="nav-text">工作负载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pod-容器组"><span class="nav-number">2.5.1.</span> <span class="nav-text">Pod (容器组)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pod-和-Controller"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">Pod 和 Controller</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Pod-Template"><span class="nav-number">2.5.1.1.1.</span> <span class="nav-text">Pod Template</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Termination-of-Pods"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">Termination of Pods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Pod-phase"><span class="nav-number">2.5.1.3.1.</span> <span class="nav-text">Pod phase</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pod-conditions"><span class="nav-number">2.5.1.3.2.</span> <span class="nav-text">Pod conditions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#健康检查-Probe-探针"><span class="nav-number">2.5.1.3.3.</span> <span class="nav-text">健康检查 - Probe (探针)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#何时使用"><span class="nav-number">2.5.1.3.3.1.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#参数"><span class="nav-number">2.5.1.3.3.2.</span> <span class="nav-text">参数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#容器的状态"><span class="nav-number">2.5.1.3.4.</span> <span class="nav-text">容器的状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重启策略"><span class="nav-number">2.5.1.3.5.</span> <span class="nav-text">重启策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化容器"><span class="nav-number">2.5.1.4.</span> <span class="nav-text">初始化容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化容器的行为"><span class="nav-number">2.5.1.4.1.</span> <span class="nav-text">初始化容器的行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Resources"><span class="nav-number">2.5.1.4.2.</span> <span class="nav-text">Resources</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pod-重启的原因"><span class="nav-number">2.5.1.4.3.</span> <span class="nav-text">Pod 重启的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#配置初始化容器"><span class="nav-number">2.5.1.4.4.</span> <span class="nav-text">配置初始化容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Debug-初始化容器"><span class="nav-number">2.5.1.4.5.</span> <span class="nav-text">Debug 初始化容器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#理解-Pod-状态"><span class="nav-number">2.5.1.4.5.1.</span> <span class="nav-text">理解 Pod 状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Disruptions-毁坏"><span class="nav-number">2.5.1.5.</span> <span class="nav-text">Disruptions (毁坏)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#处理-Disruption"><span class="nav-number">2.5.1.5.1.</span> <span class="nav-text">处理 Disruption</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Disruption-Budget"><span class="nav-number">2.5.1.5.2.</span> <span class="nav-text">Disruption Budget</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#区分集群管理员和应用管理员的角色"><span class="nav-number">2.5.1.5.2.1.</span> <span class="nav-text">区分集群管理员和应用管理员的角色</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何执行毁坏性的操作（Disruptive-Action）"><span class="nav-number">2.5.1.5.2.2.</span> <span class="nav-text">如何执行毁坏性的操作（Disruptive Action）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#配置-Pod-Disruption-Budget"><span class="nav-number">2.5.1.5.3.</span> <span class="nav-text">配置 Pod Disruption Budget</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#确定哪个应用程序需要使用-PDB-保护"><span class="nav-number">2.5.1.5.3.1.</span> <span class="nav-text">确定哪个应用程序需要使用 PDB 保护</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#思考应用程序如何处理毁坏（disruption）"><span class="nav-number">2.5.1.5.3.2.</span> <span class="nav-text">思考应用程序如何处理毁坏（disruption）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题诊断"><span class="nav-number">2.5.1.6.</span> <span class="nav-text">问题诊断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常见应用异常"><span class="nav-number">2.5.1.6.1.</span> <span class="nav-text">常见应用异常</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Pod-停留在-Pending"><span class="nav-number">2.5.1.6.1.1.</span> <span class="nav-text">Pod 停留在 Pending</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Pod-停留在-waiting"><span class="nav-number">2.5.1.6.1.2.</span> <span class="nav-text">Pod 停留在 waiting</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Pod-不断被拉取并且可以看到-crashing"><span class="nav-number">2.5.1.6.1.3.</span> <span class="nav-text">Pod 不断被拉取并且可以看到 crashing</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Pod-处在-Runing-但是没有正常工作"><span class="nav-number">2.5.1.6.1.4.</span> <span class="nav-text">Pod 处在 Runing 但是没有正常工作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Service-无法正常的工作"><span class="nav-number">2.5.1.6.1.5.</span> <span class="nav-text">Service 无法正常的工作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#应用远程调试"><span class="nav-number">2.5.1.6.2.</span> <span class="nav-text">应用远程调试</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Pod-远程调试"><span class="nav-number">2.5.1.6.2.1.</span> <span class="nav-text">Pod 远程调试</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Servic-远程调试"><span class="nav-number">2.5.1.6.2.2.</span> <span class="nav-text">Servic 远程调试</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#kubectl-debug"><span class="nav-number">2.5.1.6.2.3.</span> <span class="nav-text">kubectl-debug</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Controller-控制器"><span class="nav-number">2.5.2.</span> <span class="nav-text">Controller  (控制器)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReplicaSet"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">ReplicaSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ReplicaSet-的定义"><span class="nav-number">2.5.2.1.1.</span> <span class="nav-text">ReplicaSet 的定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deployment"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">Deployment</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建"><span class="nav-number">2.5.2.2.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#更新"><span class="nav-number">2.5.2.2.2.</span> <span class="nav-text">更新</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#覆盖更新-Rollover-（更新过程中再更新）"><span class="nav-number">2.5.2.2.2.1.</span> <span class="nav-text">覆盖更新 Rollover （更新过程中再更新）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#滚动更新"><span class="nav-number">2.5.2.2.2.2.</span> <span class="nav-text">滚动更新</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回滚"><span class="nav-number">2.5.2.2.3.</span> <span class="nav-text">回滚</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#伸缩"><span class="nav-number">2.5.2.2.4.</span> <span class="nav-text">伸缩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#暂停和继续"><span class="nav-number">2.5.2.2.5.</span> <span class="nav-text">暂停和继续</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看状态"><span class="nav-number">2.5.2.2.6.</span> <span class="nav-text">查看状态</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Progressing-状态"><span class="nav-number">2.5.2.2.6.1.</span> <span class="nav-text">Progressing 状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Complete-状态"><span class="nav-number">2.5.2.2.6.2.</span> <span class="nav-text">Complete 状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Failed-状态"><span class="nav-number">2.5.2.2.6.3.</span> <span class="nav-text">Failed 状态</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#金丝雀发布（灰度发布）"><span class="nav-number">2.5.2.2.7.</span> <span class="nav-text">金丝雀发布（灰度发布）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StatefulSet"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">StatefulSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建-1"><span class="nav-number">2.5.2.3.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pod-的标识"><span class="nav-number">2.5.2.3.2.</span> <span class="nav-text">Pod 的标识</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#序号"><span class="nav-number">2.5.2.3.2.1.</span> <span class="nav-text">序号</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#稳定的网络-ID"><span class="nav-number">2.5.2.3.2.2.</span> <span class="nav-text">稳定的网络 ID</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#稳定的存储"><span class="nav-number">2.5.2.3.2.3.</span> <span class="nav-text">稳定的存储</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#部署和伸缩"><span class="nav-number">2.5.2.3.3.</span> <span class="nav-text">部署和伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Pod-管理策略"><span class="nav-number">2.5.2.3.3.1.</span> <span class="nav-text">Pod 管理策略</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#更新-1"><span class="nav-number">2.5.2.3.4.</span> <span class="nav-text">更新</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DaemonSet"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">DaemonSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建-2"><span class="nav-number">2.5.2.4.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通信模式"><span class="nav-number">2.5.2.4.2.</span> <span class="nav-text">通信模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#更新-2"><span class="nav-number">2.5.2.4.3.</span> <span class="nav-text">更新</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Job"><span class="nav-number">2.5.2.5.</span> <span class="nav-text">Job</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义"><span class="nav-number">2.5.2.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理-Pod-和容器的失败"><span class="nav-number">2.5.2.5.2.</span> <span class="nav-text">处理 Pod 和容器的失败</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#终止和清理"><span class="nav-number">2.5.2.5.3.</span> <span class="nav-text">终止和清理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自动清理"><span class="nav-number">2.5.2.5.4.</span> <span class="nav-text">自动清理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CronJob"><span class="nav-number">2.5.2.6.</span> <span class="nav-text">CronJob</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义-1"><span class="nav-number">2.5.2.6.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收"><span class="nav-number">2.5.2.7.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#所有者和从属对象"><span class="nav-number">2.5.2.7.1.</span> <span class="nav-text">所有者和从属对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#垃圾收集器如何删除从属对象"><span class="nav-number">2.5.2.7.2.</span> <span class="nav-text">垃圾收集器如何删除从属对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Foreground-级联删除"><span class="nav-number">2.5.2.7.3.</span> <span class="nav-text">Foreground 级联删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Background-级联删除"><span class="nav-number">2.5.2.7.4.</span> <span class="nav-text">Background 级联删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#设置级联删除策略"><span class="nav-number">2.5.2.7.5.</span> <span class="nav-text">设置级联删除策略</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务与网络"><span class="nav-number">2.6.</span> <span class="nav-text">服务与网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-1"><span class="nav-number">2.6.1.</span> <span class="nav-text">Service</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建-Service"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">创建 Service</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#无-label-selector"><span class="nav-number">2.6.1.1.1.</span> <span class="nav-text">无 label selector</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟-IP-和服务代理"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">虚拟 IP 和服务代理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#User-space-代理模式"><span class="nav-number">2.6.1.2.1.</span> <span class="nav-text">User space 代理模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Iptables-代理模式-默认模式"><span class="nav-number">2.6.1.2.2.</span> <span class="nav-text">Iptables 代理模式 (默认模式)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IPVS-代理模式"><span class="nav-number">2.6.1.2.3.</span> <span class="nav-text">IPVS 代理模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务发现"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">服务发现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#环境变量"><span class="nav-number">2.6.1.3.1.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS"><span class="nav-number">2.6.1.3.2.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Headless-Services"><span class="nav-number">2.6.1.3.3.</span> <span class="nav-text">Headless Services</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟-IP-的实现"><span class="nav-number">2.6.1.4.</span> <span class="nav-text">虚拟 IP 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#避免冲突"><span class="nav-number">2.6.1.4.1.</span> <span class="nav-text">避免冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Service-的-IP-地址"><span class="nav-number">2.6.1.4.2.</span> <span class="nav-text">Service 的 IP 地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Userspace"><span class="nav-number">2.6.1.4.3.</span> <span class="nav-text">Userspace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iptables"><span class="nav-number">2.6.1.4.4.</span> <span class="nav-text">iptables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IPVS"><span class="nav-number">2.6.1.4.5.</span> <span class="nav-text">IPVS</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConfigMap"><span class="nav-number">2.7.</span> <span class="nav-text">ConfigMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Secret"><span class="nav-number">2.8.</span> <span class="nav-text">Secret</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务发现-1"><span class="nav-number">2.9.</span> <span class="nav-text">服务发现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Helm"><span class="nav-number">2.10.</span> <span class="nav-text">Helm</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chaosn Chan</span>

  

  
</div>









<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count"> 全站共 89.7k 字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  
    <script type="text/javascript">
    (function() {
        // 匿名函数，防止污染全局变量
        var utterances = document.createElement('script');
        utterances.type = 'text/javascript';
        utterances.async = true;
        utterances.setAttribute('issue-term','pathname')
        utterances.setAttribute('theme','github-light')
        utterances.setAttribute('repo','chenchensheng/chanson.github.io')
        utterances.crossorigin = 'anonymous';
        utterances.src = 'https://utteranc.es/client.js';
        // content 是要插入评论的地方
        document.getElementById('gitment-container').appendChild(utterances);
    })();
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
